---
title: DC 모터 라인트레이서
date: 2025-01-27 01:28
tag: [Embedded]
category: dev
description: "DC 라인트레이서를 제작하며 학습한 임베디드 소프트웨어/모터 제어 지식과, 마주했던 급발진/저주파음 문제를 해결한 경험을 소개합니다."
---

## 목차

0. 들어가며
1. DC 라인트레이서 소개
2. PID 제어
3. PWM(Pulse Width Modulation)
4. 급발진(?) 문제 해결
5. 저주파음 발생 문제 해결
6. 나오며

## 0. 들어가며

이번 포스팅은 DC 모터를 활용한 라인트레이서를 중심으로 진행됩니다. 첫째로 STEP 라인트레이서와 비교하며, DC 라인트레이서를 간단히 소개하겠습니다. 둘째로 모터 제어에 활용한 PID 제어에 대한 정보를 정리하겠습니다. 셋째로 PWM이라는 펄스 변조 방식에 대하여 설명하겠습니다. 넷째로 라인트레이서의 급발진(?) 문제를 해결한 경험을 소개하겠습니다. 다섯 번째로 모터에서 갑작스럽게 발생한 저주파음 문제를 해결한 경험을 소개하겠습니다. 마지막으로 내용을 정리하며 글을 마무리하겠습니다.

## 1. DC 라인트레이서 소개

DC 라인트레이서는 STEP 라인트레이서와 크게 2가지의 차별점이 있습니다. 첫째로 DC 모터를 사용합니다. 둘째로 8개의 센서에서 16개로 증가된 센서를 사용하는 것이 일반적입니다. 소프트웨어의 경우, STEP 라인트레이서에서 작성한 코드가 적절히 모듈화되어 있다면, 모터 및 센서 관련 코드만 변경해도 동작할 수 있습니다. 하지만 DC 모터와 STEP 모터의 차이를 이해하고, 제어 방법을 학습하는 것이 필요합니다. DC 모터는 STEP 모터와 어떻게 다를까요? 차근차근 살펴봅시다.

먼저 STEP 모터는 전자기 코일과 영구자석을 이용하여, 한 스텝 단위로 제어됩니다. 특정 전자기 코일에 전류를 흘려보내주면, 영구자석은 정해진 각도 만큼 움직입니다. 이렇게 특정각도 만큼 한번 움직인다면, 이를 한 스텝이라고 합니다. 즉, STEP 모터는 스텝당 회전 각도가 고정되어 있습니다. 즉, 정밀한 위치제어가 가능합니다.

하지만 DC 모터는 다르게 작동합니다. DC 모터는 코일에 전류를 흘려 자기장을 발생시키며 동작합니다. 이때, STEP 모터와 달리, 전압에 따라 정해지지 않은 각도만큼 움직입니다. 즉, 위치를 정확히 제어하기 어렵습니다.

그렇다면 DC 모터를 왜 라인트레이서에 활용할까요? 그것은 STEP 트레이서의 고질적인 문제를 해결하기 위함에 있습니다. STEP 모터는 고속에서 높은 토크(힘)를 내기 어렵습니다. 이에 STEP 트레이서는 고속으로 주행할 시에 충분한 토크를 가지지 못하며, 매우 빈번하게 모터 제어 불능의 상태에 빠집니다. 이는 라인트레이서가 빠르게 주행하는 것에 치명적입니다. 라인트레이서 대회의 규정은 대체로 어떤 로봇이 완주를 빨리하느냐로 초점이 맞춰져 있기 때문에, 이러한 한계를 극복해야할 것입니다.

그런데 DC 모터는 고속에서 높은 효율을 가지며, 일반적으로 STEP 모터보다 높은 토크(힘)를 발휘합니다. 만약 DC 모터로 정밀한 위치(각도) 제어가 가능하다면, DC 라인트레이서는 높은 토크를 유지하면서도 고속에서 정밀하게 동작할 수 있습니다. 즉, 정밀한 위치제어가 가능하다면, DC 모터 라인트레이서의 성능은 STEP 모터 라인트레이서보다 매우 향상됩니다.

|                     | STEP 모터 | DC 모터   |
| ------------------- | --------- | --------- |
| **정밀한 위치제어** | 용이함    | 까다로움  |
| **고속회전**        | 낮은 토크 | 높은 토크 |

그렇다면 DC 모터에서 정밀한 위치제어는 어떻게 구현해야할까요? 크게 4단계로 구성됩니다.

먼저, '현재 위치(각도)'를 알아야 합니다. 이는 Encoder라는 센서를 통하여 알 수 있습니다. Encoder는 기계적인 각도 등을 측정하여 전기적인 신호로 출력하는 센서입니다. 이때, Encoder는 분해능이 중요하며, 분해능이란 모터가 1바퀴 회전할 때 발생하는 신호의 개수입니다. 즉, Encoder에서 몇개의 신호가 왔는지 파악한다면, '현재 위치'를 파악할 수 있습니다.

둘째로, 정해진 주기마다 '추종해야할 위치(각도)'를 지정해야합니다. 속도가 정해지면, 모터의 각도가 얼마나 이동해야하는지 계산할 수 있습니다. 즉, 속도를 통하여 '추종해야할 위치'를 계산합니다. 예를 들어, 속도는 2(m/s)고, 제어주기는 0.01(s)이며, 모터가 1회 회전할 때, 0.1(m)를 이동하고, Encoder의 분해능이 1000이라고 가정합시다. 이때 2(m/s)의 속도로 이동하려면, 제어주기인 0.01(s) 동안, 0.02(m) 이동해야합니다. 0.02(m)를 이동하기 위해서는 모터가 1/5회(=0.02/0.1) 회전해야합니다. 즉, 모터가 한 제어주기당 이동해야하는 위치는, Encoder 신호 개수를 기준으로, 200(=1000/5)입니다. 이를 통해 정해진 주기마다 '추종해야할 위치'를 계산할 수 있습니다.

('현재 위치'와 '추종해야할 위치'와 관련하여, 라인트레이서를 제작할 때 혼동했던 부분을 짚고 넘어가겠습니다. 예시에서 '추종해야할 위치'는 200씩 늘어납니다. 하지만 각 주기마다 200만큼만 이동해도 문제가 없는 상황은 굉장히 이상적인 상황입니다. 1번째 주기에서 200만큼 이동해야했지만, 실제로는 190만큼 이동했다면, 다음 주기에서 210만큼 이동해야합니다. 정리하면, ['이전 제어주기의 추종해야할 위치' + 200] == ['현재 제어주기의 추종해야할 위치']이고, '현재 위치'는 실제 모터의 위치입니다. 즉, ['현재 위치' + 200]과 ['추종해야할 위치']는 같지 않습니다.)

셋째로, '현재 위치'와 '추종해야할 위치'의 차이인 Error(오차)를 통하여 적절한 전압을 계산합니다. 이는 PID 제어를 활용합니다.

마지막으로 계산된 전압을 모터에 인가해야 합니다. 이때 모터는 모터 드라이버를 통하여 제어됩니다. 또한, 모터 드라이버에 전압 정보를 전달하면, 모터 드라이버는 해당 전압을 모터에 인가합니다." 즉, 모터 드라이버에 전압 정보를 전달하면, 모터 제어가 가능합니다. 저희 동아리에서 사용하는 모터 드라이버는 PWM을 통하여 전압 정보를 전달 받습니다.

사실 실제 제어는 위의 내용과 비교했을때, 조금은 다른 방식으로 진행됩니다. 하지만 전반적인 개념을 이해하는 데에는 위의 설명이 더 유익할 것으로 판단되어, 이 방식으로 설명을 이어가겠습니다. 지금부터는 PID 제어와, PWM을 면밀히 살펴보겠습니다.

## 2. PID 제어

PID 제어는 피드백 제어의 일종입니다. 이때 피드백 제어란, 제어를 한 결과(피드백)을 바탕으로 다시 제어하는 것입니다.

여기에서 우리는 한가지 사실을 확인할 수 있습니다. 피드백 제어는 폐쇄 루프 시스템에서 이용할 수 있습니다. 폐쇄 루프 시스템은 무엇일까요? 우리의 라인트레이서가, 엔코더 값을 기준, 200을 이동 후 멈춰야한다고 가정합시다. 이때 첫번째 제어에서 200보다 많은 220을 갔습니다. 이때 두번째 제어에서 200에 도달하기 위하여, -20을 이동하도록 제어했습니다. 그러나 -22를 이동하였고, 최종적으로 198에 도달했습니다. 세번째 제어에서는 2만큼 이동하도록 제어할 것입니다. 이때 "제어 -> 피드백 -> 제어 -> ..."의 과정을 반복합니다. 즉, 흐름이 반복되는 것이 폐쇄 루프 시스템입니다. (폐쇄 루프 시스템과 반대의 개념으로 개방 루프 시스템이 있습니다. 이는 "제어 -> 피드백"이 단 한번만 이루어지는 것을 예시로 들 수 있습니다. 즉, 흐름이 반복되지 않습니다.)

라인트레이서의 제어도 폐쇄 루프 시스템에 해당하기 때문에, 피드백 제어를 적용할 수 있습니다. 그 중 PID 제어를 통하여 모터를 제어하였습니다. PID 제어는 실제 값과 목표 값의 오차를 이용해 적분 및 미분 연산을 수행하여 적절한 제어 값을 산출합니다. 즉, 오차의 비례-적분-미분항을 통하여 제어값을 계산합니다. 다음은 각각의 항의 제어작용과 계산식을 서술한 표입니다.

|              | 비례항               | 적분항                        | 미분항                        |
| ------------ | -------------------- | ----------------------------- | ----------------------------- |
| **제어작용** | 오차에 비례하여 제어 | 정상상태 오차 제거            | 제어값의 급격한 변화를 억제   |
| **계산식**   | Kp(p gain) \* (오차) | Ki(i gain) \* (오차의 적분값) | Kd(d gain) \* (오차의 미분값) |

여기에서 적절한 p gain, i gain, d gain를 튜닝하는 것이 중요합니다. 이러한 gain은 수동으로도 튜닝하고, 요새는 딥러닝 등을 통하여 자동으로도 튜닝하는 것으로 압니다. 다음은 각각의 gain이 증가했을때, 일반적으로 나타나는 반응을 정리한 표입니다.

|                      | p gain | i gain    | d gain       |
| -------------------- | ------ | --------- | ------------ |
| **상승시간**         | 감소   | 작은 증가 | 큰 변화 없음 |
| **초과량(오버슈팅)** | 증가   | 증가      | 감소         |
| **정착 시간**        | 증가   | 증가      | 감소         |
| **정상 편차**        | 감소   | 큰 감소   | 큰 변화 없음 |
| **안정성**           | 감소   | 감소      | 향상         |

- 상승시간: 목표값의 90%까지 도달하기까지 걸리는 시간
- 초과량(오버슈팅): 목표값을 초과하는 양
- 정착 시간: 목표값의 95% 혹은 99%까지 도달하기까지 걸리는 시간
- 정상 편차: 목표값으로부터의 최종 오차
- 안정성: 목표값에 머무르려는 성질

최종적으로 각각의 비례-적분-미분항을 합하여 제어값(전압)을 산출합니다. 정리하면, 라인트레이서의 제어값(전압)은 '현재 위치'와 '추종해야할 위치'의 차이인 오차를 통하여, 비례-적분-미분항을 구하고, 이를 합하여 제어값(전압)을 계산합니다.

이 과정을 끝내면 우리는 제어값인 전압을 얻게 됩니다. 하지만 이는 단순히 값을 산출한 것에 불과합니다. 우리는 이 제어값을 모터 드라이버에 전달하여, 실제 모터가 해당 전압으로 구동되도록 만들어야합니다. 지금부터는 제어값을 모터 드라이버에 전달하는 방식인 PWM에 대하여 살펴보겠습니다.

## 3. PWM(Pulse Width Modulation)

PWM은 펄스 폭 변조로도 불립니다. 이름 그대로, 펄스 폭을 조절하여 신호를 전달합니다. Duty Cycle이 높을수록, 펄스 폭은 늘어납니다. 아래 사진을 통하여 살펴봅시다.

<img src="/api/posting/dev/dc-linetracer/img/1.jpg" alt="pwm-with-duty-cycle" width="400" height="438" loading="lazy">

라인트레이서의 경우 Duty Cycle이 높을수록, 높은 전압을 인가합니다. 이때, PID 제어를 통하여 계산된 전압을 바탕으로, 어떻게 펄스 폭을 변경해야할까요? [계산된 전압 / 실제 배터리 전압]의 값으로 Duty Cycle을 변경하면 됩니다. 다음으로 PWM을 생성하는 역할을 할 수 있는 10번/11번 타이머로, 변경된 Duty Cycle을 반영하여, 펄스 파를 모터 드라이버에게 전송합니다. 그렇다면 모터 드라이버는 전달된 정보를 바탕으로, [배터리에서 공급받는 전압 \* Duty Cycle]로 모터를 구동하게 됩니다.

이렇게 저희는 DC 모터를 정밀하게 제어할 수 있게 되었습니다. 지금부터는 DC 모터 트레이서를 제작하며 겪은 문제를 해결한 경험을 소개하겠습니다.

## 4. 급발진(?) 문제 해결

저의 금쪽이 라인트레이서는 무려 급발진을 할 수 있었습니다. 급발진 문제는 모터 드라이버를 새로 납땜하여 테스트하는 상황에서 발생하였습니다. 전원을 인가한 직후, 모터가 불규칙한 주기로 매우 빠르게 회전하다가 정지하는 현상이 반복되었습니다.

이때 모터 드라이버를 동아리 선배가 사용했던 모터 드라이버로 교체한 결과 문제가 해결되었습니다. 즉, 새로 납땜한 모터 드라이버에 문제가 있었습니다. 이때 동아리 선배가 사용했던 모터 드라이버와 새로 납땜한 모터 드라이버에는 한가지 차이점이 있었습니다. 새로 납땜한 모터 드라이버의 신호선에는 Pull-down 회로가 적용되어있지 않았습니다.

Pull-down이란, 신호선의 기본 전압을 0V로 고정하는 것을 의미합니다. Pull-down을 하지 않는다면, 회로의 디폴트 전압은 0v로 고정되지 않으며, 0v보다 높은 전압이 디폴트 전압이 될 수 있습니다. 즉, floating 현상이 발생합니다. 이때 PWM 신호에 floating이 된다면, 이는 치명적입니다. 0v보다 높은 전압이 디폴트 전압이 된다면, 모터 드라이버에 Duty Cycle이 0%인 신호를 보내고 있어도, 모터 드라이버는 Duty Cycle이 0%보다 높은 신호로 해석할 수도 있습니다. 즉, 모터의 동작을 의도하지 않았음에도 불구하고, 모터가 동작하는 상황이 생길 수 있습니다.

저의 라인트레이서 또한 PWM 신호선에서 floating 현상이 발생하여, 급발진을 하던 것으로 파악하였습니다. 따라서 저는 STM 보드 자체에도 Pull-down을 설정할 수 있는 기능이 있기에, STM 보드에서 Pull-down을 하였습니다.

하지만 문제는 여전히 남아있었습니다. STM 보드에서 Pull-down을 하기 전에는, 전원 인가 후 어느 시점이든 급발진을 하였습니다. 그런데 STM 보드에서 Pull-down을 한 이후에는, 전원 인가 후 1초 정도만 급발진을 하고 멈췄습니다. 급발진 문제는 완화되었을 뿐, 여전히 완전한 해결에 도달하지 못한 상황이었습니다.

해당 문제는 모터 드라이버에 전원이 인가되는 시점보다 개발보드가 켜져서 Pull-down이 진행되는 시점이 느리다는 것에 기인하였습니다. 즉, PWM 선이 floating 되어있는 상태에서, 모터 드라이버에 전원이 인가되기 때문에, 일단 급발진을 시작합니다. 그러다 개발보드가 켜지고 Pull-down이 진행된다면, 급발진을 멈추는 것이지요. 따라서 기판에 Pull-down 회로를 추가하여, STM 보드가 켜지기 이전에도 Pull-down이 되도록 회로를 구성하였습니다. 이런 방법으로 금쪽이 라인트레이서의 급발진을 해결하였습니다.

사실 floating을 방지하는 것은 기본 중의 기본입니다. 하지만 저는 이를 간과하여 소중한 시간을 허비하였습니다. 사실 기본을 챙기는 것은 매우 중요합니다. 이 문제 외에도 DC 트레이서는 기본이지만 놓치기 쉬운 요소들이 굉장히 많습니다. 예를들어, 나사를 잘 체결하기 등이 있습니다. 남들이 보면 "나사 잘 조이는게 대수야?"라고 생각할 것이 눈에 훤합니다. 하지만 트레이서의 경우 나사 하나 잘못 조여서, 대회에서 1등할 트레이서가 수상하지 못하는 경우가 매우 빈번하게 일어납니다. 탑은 기초부터 명확하고 꼼꼼히 쌓아야합니다. 이번 문제를 해결하며, 기본적인 사항을 꼼꼼히 체크하는 것의 중요성을 실감했습니다.

앞으로 이런 기본적인 사항을 꼼꼼히 지키기 위해서는, 단순히 "신경쓴다"의 개념이 아닌, 꼼꼼해질 수 밖에 없는 상황을 만드는 것이 중요하다고 생각합니다. 체크리스트를 만들어 점검하는 등의 노력을 통하여, 기본적이지만 놓치기 쉬운 부분을 챙기려합니다.

## 5. 저주파음 발생 문제 해결

9번 타이머에서 실행되는 모터 제어 코드를 변경했더니, 모터에서 저주파음이 덤으로 딸려왔습니다. (1+1!) 이전에 사용했던 모터 제어 코드를 사용하니, 저주파음이 나지 않는 것으로 보아, 코드 변경으로 인하여 어떤 문제가 발생한 것으로 판단하였습니다.

이때 이전에 STEP 트레이서를 제작하며 1-2상 여자제어에서 2상 여자제어로 변경했던 경험을 떠올렸습니다. 그 당시, 2상 여자제어로 변경했더니, 제어 주기가 늘어남에 따라 모터의 구동음이 기존보다 낮은 소리로 들렸습니다. 이를 통해 제어주기에 문제가 있으리라 추측했습니다.

PWM 신호는 타이머 10번/11번을 통하여 생성됩니다. 이때 타이머 10번/11번이 정상적으로 동작하지 못하고, 이에 따라 제어주기가 길어질 수 있는 요인을 검토해보았습니다.

제가 당시에 생각한 요인은 다음과 같습니다. 변경 전의 9번 타이머는 연산량이 많지 않았습니다. 하지만 변경 후의 9번 타이머는 연산량이 굉장히 많아졌습니다. 더하여 센서를 더욱 잘 읽을 수 있도록, 센서 코드가 동작하는 타이머를 더욱 빠르게 호출했었습니다. 즉, 다른 타이머에서 연산량이 매우 많아져서, 타이머 10번/11번이 제때 호출되지 못할 수도 있다고 판단하였습니다.

이에 변경한 모터코드를 최적화하고, 센서 타이머의 호출주기를 이전으로 되돌렸습니다. 그러자 모터가 저주파음 없이 깔끔하게 동작하였습니다.

하지만 더이상 최적화가 불가능하는 등의 타협점이 없는 경우라면, 이런 문제를 어떻게 해결해야할까요? 오랜 시간 고민해본 결과, 타이머 interrupt를 처리하는 순서를 지정해주는 방법도 유용하다고 판단하여 소개해볼까합니다.

STM32CubeIDE에서는 다음과 같이 interrupt들의 Preemption Priority(선점 우선순위)와 Subpriority(서브 우선순위)를 설정할 수 있습니다.

<img src="/api/posting/dev/dc-linetracer/img/2.jpg" alt="stm32cubeide-interrupt-priority-setting" width="600" height="430" loading="lazy">

Preemption Priority(선점 우선순위)는 우선 순위가 낮은 interrupt가 실행중이더라도, 우선 순위가 높은 다른 interrupt에 의해 선점(중단)되는 것을 허용합니다. 그리고 우선 순위가 높은 interrupt가 종료되면, 우선 순위가 낮은 interrupt는 중단된 부분부터 계속됩니다.

Subpriority(서브 우선순위)는 선점 우선순위가 동일한 2개의 다른 interrupt가 동시에 발생했을때, 어떤 interrupt를 먼저 실행시킬지를 결정합니다. 선점 우선순위가 동일하며, 서브 우선순위가 높은 A와, 서브 우선순위가 낮은 B의 interrupt가 동시에 발생했을때, A가 먼저 실행되고, A가 종료되면, B를 실행합니다.

제가 생각했을때, 저주파음 발생문제를 해결하기 위해서, 9번 타이머의 interrupt의 선점 우선순위를 낮추는 것이 합당하다고 생각합니다.

일단 9번 타이머는 연산량이 많기에, 상대적으로 많은 시간이 소요됩니다. 긴 시간 동안 10번/11번 타이머는 실행되지 못하기 때문에, 10번/11번 타이머가 9번 타이머의 실행에 대해서 선점할 필요가 있어보입니다. 그런데 9번 타이머가 중단되고 다시 실행함으로 인하여 다른 문제가 생기진 않을까요?

9번 타이머를 제외하고 연산 시간이 많이 걸리는 타이머는 없기 때문에, 9번 타이머는 중단되고 다시 실행해도 중단된 시간이 크지 않게 됩니다. 더하여 9번 타이머는 코드 로직상 중단되었다 다시 시작해도 큰 문제가 없습니다. (반면 센서 타이머의 경우, ADC를 읽어오다가 중단되면 문제가 생길 수 있습니다.) 즉, 9번 타이머가 중단되어도, 짧은 시간동안 중단되는 것이고, 코드 로직상 중단되어도 무방하기 때문에, 큰 문제가 없으리라 판단합니다.

즉, 9번 타이머의 선점 우선순위를 낮춰서 발생하는 장점/단점을 비교해 보았을때, 장점이 크다고 판단합니다. 그러나 아직 테스트를 해보지 않은 가정에 불과하기에, 참고삼아 봐주시길 바랍니다.

정리하면, 저주파음 발생 문제는 타이머 interrupt의 주기와 관련한 문제였고, 이를 해결하기 위하여 최적화/우선순위지정 등의 방법을 살펴보았습니다. 이번 문제는 문제 지점을 찾기가 정말 어려웠습니다. 더하여 해결책을 찾는 것도 마땅치 않았던 것 같습니다. 이때 STEP 모터 라인트레이서 제작에서의 경험이 문제해결에 도움이 되었던 것 같습니다. 더하여 문제를 해결하기 위해, 공식문서를 찾아보며 선점 우선순위와 관련한 학습을 진행한 경험 또한 뜻깊었습니다.

## 6. 나오며

지금까지 DC 라인트레이서/PID 제어/PWM에 대해 소개하고, DC 라인트레이서를 제작하며 겪었던 문제와 해결책을 공유하였습니다. DC 라인트레이서를 제작하며 PID 제어/PWM 등의 모터 제어 관련 지식을 얻었습니다. 더하여 급발진 문제를 해결하며, 기본을 꼼꼼하게 점검하는 것의 필요성을 실감하였습니다. 마지막으로 저주파 발생 문제와 관련하여, 문제상황을 찾기 어렵고 해결책을 도출하기에 쉽지 않은 문제를, 이전 경험/공식문서/가치판단 등을 통하여 풀어간 경험을 소개하였습니다. 이만 글을 줄이겠습니다.

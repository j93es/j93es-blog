---
title: "STEP 모터 라인트레이서"
date: 2025-01-07
tag: [Embedded]
category: dev
description: "STEP 라인트레이서를 제작하며 경험한 모듈화의 중요성, 테스트 시 외부변수 차단, 임베디드에서의 의존성 주입과 관련한 생각을 공유합니다."
---

## 목차

0. 들어가며
1. STEP 라인트레이서 소개
2. 모듈화의 중요성
3. 성능 향상을 위한 방법 테스트
4. 테스트와 의존성 주입
5. 나오며

## 0. 들어가며

이번 글은 STEP 모터를 활용한 라인트레이서를 중심으로 진행됩니다. 첫째로 STEP 라인트레이서를 간단히 설명해볼까 합니다. 둘째로 라인트레이서 제작에서 느낀 모듈화의 중요성을 논해볼까 합니다. 셋째로 성능향상을 위한 여러 방법을 테스트할 때에 얻었던 경험을 공유하겠습니다. 넷째로 테스트를 진행할 때에 의존성 주입을 어떻게 활용할 수 있을지에 대한 고민을 소개해보겠습니다. 마지막으로 포스팅을 정리하며, 글을 마무리하려합니다.

## 1. STEP 라인트레이서 소개

라인트레이서는 검은색 배경 위에 흰색 선이 배치된 맵에서, 해당 선을 따라 주행하는 로봇입니다. 라인트레이서 대회의 규정은 대체로 어떤 로봇이 완주를 빨리하느냐로 초점이 맞춰져 있습니다. 로봇이 동작하는 대회 영상은 [유튜브 링크](https://youtube.com/@zerotoinfinite2418?feature=shared)를 통하여 확인해볼 수 있습니다. 또한, 다양한 주행 전략을 활용하여 기록을 단축할 수 있습니다. 예를 들어, 첫 번째 주행에서 직선 구간의 정보를 저장해 둔 뒤, 이후 주행에서는 직선 가속을 적용하는 전략을 사용할 수 있습니다.

이때 라인트레이서의 구체적인 구현은 어떻게 이루어질까요? 먼저 라인트레이서의 구성 요소에 대해 살펴봅시다. 크게는 회로, 소프트웨어, MCU, 모터, 배터리 등으로 나눌 수 있습니다.

먼저 MCU, 모터와 배터리를 살펴보겠습니다. MCU는 STM32F411을 사용하였으며, 모터는 STEP 모터, 배터리는 12셀(44.4V)을 활용하였습니다. STEP 모터는 저렴하고 제어가 비교적 쉽다는 장점이 있습니다.(참고로 카메라 렌즈의 STM 모터도 STEP 모터의 일종입니다.) 더하여 배터리는 모터 드라이버의 데이터시트에 기초하여, 모터 드라이버가 버틸 수 있는 최대 전압을 고려하였습니다.

다음으로 회로 구성에 대해 살펴보겠습니다. 회로는 파워, 센서 보드, 센서 신호, 모터 드라이버, 모터 신호 등으로 나눌 수 있습니다.

파워 회로는 배터리에서 나온 전압을 보드가 사용할 수 있는 전압으로 낮추는 데에 초점이 맞춰져 있습니다. 배터리는 12셀을 활용하는데, 이는 약 44.4v에 해당합니다. 이런 전압을 보드에 직접 인가하면 보드는 연기가 피어오르며 사용할 수 없게 됩니다. 따라서 약 44.4v를 5v 혹은 3.3v로 바꾸는 것이 파워 회로의 역할입니다.

센서 회로는 흰색과 검은색을 구분하기 위하여 8개의 IR 센서를 활용하며, 센서 보드는 8개의 IR 센서를 달아둔 보드를 의미합니다. IR 센서는 아날로그 신호를 전달합니다. 하지만 아날로그 신호를 가공하기는 어려움으로, 이를 디지털 신호로 바꿀 필요가 있습니다. 그런데 아날로그 신호를 디지털 신호로 변환하는데에는 ADC가 필요합니다. 이때, STM32F411에는 ADC가 단 하나뿐이기 때문에, 8개 센서의 아날로그 신호를 한번에 디지털 신호로 전환할 수 없습니다. 이에 MUX라는 소자를 활용하여 8개의 센서를 하나씩 차례로 ADC와 연결하여, 8개의 아날로그 신호를 차례대로 디지털 신호로 전환합니다.

모터 회로는 모터 드라이버를 이용합니다. 더하여 모터 드라이버는 적절한 신호를 통해 제어됩니다. 모터 신호와 관련한 회로는 Pull-down을 통하여 floating을 방지하여야 합니다. 이때 floating에 대해 설명해보겠습니다. 모터 드라이버는 0v는 0으로 5v는 1로 해석한다고 가정합시다. 이때 신호선에 Pull-down을 해주면 신호선의 기본 전압은 0v가 됩니다. 하지만 Pull-down을 하지 않는다면 2.1v, 3.5v 등의 0v 이상의 전압이 기본 상태가 될 수 있으며, 이는 신호를 안정적으로 제어하기 어렵게 하는 원인입니다. 이처럼 모터와 관련한 회로는 모터 드라이버에 안정적으로 신호를 전달하는 역할을 합니다. 더하여 모터 드라이버는 입력된 신호에 기반하여, 약 44.4v의 전압으로 모터를 제어합니다.

마지막으로 소프트웨어 구성에 대해 살펴보겠습니다. 소프트웨어는 정말 간단하게 센서, 모터, 조향, 주행전략 부분으로 나눌 수 있습니다. 특히 센서, 모터, 조향은 Timer interrupt를 활용하여 특정 주기마다 실행됩니다. 센서 코드는 MUX를 제어하고 ADC 값을 읽어온 후, 값을 바탕으로 로봇의 위치를 추정하는 등의 역할을 합니다. 조향 코드는 이렇게 추정된 위치를 바탕으로 왼쪽 모터와 오른쪽 모터의 속도를 결정하는 역할을 합니다. 모터와 관련된 코드는 한번 호출되면 STEP 모터의 1/400(혹은 정해진 다른 각도)을 돌립니다. 특히 모터 코드는 결정된 속도를 바탕으로 호출되는 주기가 변화하며, 속도가 빠르면 빠르게, 속도가 느리면 느리게 호출됩니다. 그리고 주행 전략 부분은 라인트레이서가 지금 직선에서 가속을 해야하는지, 혹은 경기가 끝나서 멈춰야하는지 등을 결정합니다.

지금까지 구체적인 구현을 살펴보며 관련한 지식을 살펴보았습니다. 구현을 정말 간략히 설명했기에 중간중간 빠진 부분이 많지만, 핵심을 최대한 짚으려 노력했습니다. 지금부터는 이렇게 각 구성요소를 나누어서 얻었던 이점에 대해 살펴보며, 모듈화에 대한 저의 생각에 대해 이야기해보겠습니다.

## 2. 모듈화의 중요성

라인트레이서는 각 구성요소가 나누어져있습니다. 이런걸 모듈화라고 하겠지요. 그런데 모듈화를 하게된다면 어떤 이점이 있을까요? STEP 라인트레이서를 제작하며 느꼈던 모듈화의 이점인, 디버깅이 쉬워진다는 것을 살펴보겠습니다.

라인트레이서를 제작하는 사람은 수많은 문제에 직면할 것 입니다. 제가 겪었던 문제상황 중 하나를 예시로 들어볼까 합니다. 전날까지는 멀쩡히 정상적으로 구동하던 라인트레이서가 갑자기 센서값을 읽어오지 못하는 문제가 있었습니다. 이제 문제의 원인을 찾고 해결해야할 것 입니다.

그런데 임베디드 개발의 디버깅은 높은 레벨 개발의 디버깅과는 조금 차이가 있습니다. 대부분의 경우 높은 레벨에서는 콜스택이 명확히 에러 메세지에 표출되며, 문제지점을 정확히 찾을 수 있습니다. 프로그램이 문제지점을 찾아주고 개발자는 단순히 문제지점의 코드를 수정하면 됩니다. 그런데 임베디드 개발은 그렇지 않습니다. 문제지점을 찾기가 정말 어렵습니다. 회로에 문제가 있을 수도 있고, 센서 자체에 문제가 있을 수도 있으며, 코드를 수정하여 문제가 발생한 것일 수도 있습니다. 이러한 상황에서 저는 문제지점을 찾기 위하여, 문제의 여집합을 찾아나가는 방향으로 디버깅을 진행합니다.

예를 들어 보겠습니다. 가장 쉬운 방법인, 현재 사용 중인 코드를 이전에 정상작동한 코드로 교체해봅니다. 코드가 정상이라면, 문제의 가능성이 제일 높은 센서 보드를 교체하여, 센서 보드가 정상인지 판단합니다. 이렇게 나름의 우선순위를 정하고, 정상인 것의 범주를 명확히 파악해보고는 합니다. 즉, 정상 파츠와 교체해보며, 문제 발생 부분의 여집합을 확장시켜 나갑니다. 결론적으로 센서가 먹통이 된 원인이 단선된 센서 연결 케이블에 있었다는 것을 알아내고 허탈함에 헛웃음을 짓곤 했었습니다. 여기에서 모듈화의 이점이 드러납니다. 정상의 범위를 확장해나가고, 문제 지점을 명확히 찾아 나가기 위해서는, 정상 파츠와 교체해보는 과정이 필요했었습니다. 이처럼 모듈화는 디버깅에 이점을 가집니다.

사실 문제지점을 명확히 할 수 없는 경우는 높은 레벨의 개발에서도 심심치 않게 찾아볼 수 있겠습니다. 예를들어 "웹사이트의 성능이 문제인데 어떻게 향상시킬 것인가?" 등이 있겠네요. 제가 이런 문제에 당면했을때 임베디드 개발에서 겪었던 디버깅 경험이 유용하게 작용했던 것 같습니다.

## 3. 성능 향상을 위한 방법 테스트

라인트레이서의 성능의 척도는 무엇일까요? 바로 "얼마나 빠르게 주행할 수 있는가?" 일 것입니다. 그런데 어떻게 속도를 향상시킬 수 있을까요? 이에 대해 매우 많은 시도와 시행착오를 겪었습니다.

하나의 예를 들어보겠습니다.먼저 STEP 모터는 속도 변화에 취약합니다. 가속도를 너무 높이면, STEP 모터는 제어 불능 상태에 빠지게 되는 치명적인 상황에 도달할 수 있습니다. 이에 저는 STEP 모터의 제어방식에 주목하였습니다. 즉, 모터 제어 방식을 변화시킴으로써 가속도를 높여도 안정적으로 동작하게끔 만드는 것을 목표로 하였습니다.

기존 동아리에서 STEP 모터를 제어하는 방식은 1-2상 여자제어방식이었습니다. 제가 고려한 방식은 2상 여자제어방식입니다. 2상 여자제어방식은 타 방식에 비해 안정적으로 모터를 구동시킬 수 있으나, 소비전력이 높은 단점을 지닙니다. 하지만 저의 라인트레이서 프로젝트에서는 소비전력이 높더라도 안정적으로 제어하는 것이 유리하다고 판단하여, 모터의 구동방식을 2상 여자제어방식으로 전환해보았습니다.

이때 기존의 방식과 새로운 방식에 대한 성능평가는 어떻게 진행해야할까요? 동일한 맵을 주행하며 기록한 시간을 측정하는 방법이 있을 것입니다. 하지만 맵에 묻어있는 먼지, 배터리의 전압 등 여러 변수가 일정하지 않은 상태에서 주행기록은 성능측정의 요소로 쓰이기 어려웠습니다. 실제로 기존의 방식과 새로운 방식은 그 결과가 들쭉날쭉하게 측정되었습니다. 이러한 경험을 통하여 성능평가에서 다른 변수를 고정하는 것의 중요성을 깨달았습니다.

## 4. 테스트와 의존성 주입

1-2상 여자제어방식과 2상 여자제어방식을 테스트할 때, 주석을 통하여 모터 제어 방식을 전환하였습니다. 아래 예시를 첨부하겠습니다.

- config.h

```C
/* 생략 */

// 2상 여자제어방식
//#define SPEED_COEF  ( 31415.92f * TIRE_RADIUS )

// 1-2상 여자제어방식
#define SPEED_COEF  ( 15707.96f * TIRE_RADIUS )

// 2상 여자제어방식
//#define TICK_PER_M  ( 31.831f / TIRE_RADIUS )

// 1-2상 여자제어방식
#define TICK_PER_M  ( 63.662f / TIRE_RADIUS )

/* 생략 */
```

- motor.c

```C
/* 생략 */

// 2상 여자제어방식
//extern uint8_t  phaseL_table[4];
//extern uint8_t  phaseR_table[4];

// 1-2상 여자제어방식
extern uint8_t  phaseL_table[8];
extern uint8_t  phaseR_table[8];

/* 생략 */
```

이렇게 여러 파일에 걸쳐 주석을 바꾸어가며 방식을 변경시키는 것은, 굉장히 비효율적이고 개발자의 실수를 일으킬 수 있다고 생각합니다. 이러한 고민을 품은채로 다른 개발을 진행하다 좋은 해결책을 하나 발견하여 소개해볼까 합니다. 이 코드에서 문제점은 1-2상 여자제어방식과 2상 여자제어방식이라는 각기 다른 두개의 로직을 한 파일에 담고 있다는 것에 기인합니다. 따라서 지금 코드를 짠다면 저는 파일을 분리하고 의존성을 주입하는 형태로 구성할 것입니다.

- motor-v1.h

```C
// 1-2상 여자제어방식
#define SPEED_COEF  ( 15707.96f * TIRE_RADIUS )
#define TICK_PER_M  ( 63.662f / TIRE_RADIUS )

uint8_t             phaseL_table[8];
uint8_t             phaseR_table[8];

/* 1-2상 여자제어방식 모터 제어 함수를 export */
```

- motor-v2.h

```C
// 2상 여자제어방식
#define SPEED_COEF  ( 31415.92f * TIRE_RADIUS )
#define TICK_PER_M  ( 31.831f / TIRE_RADIUS )

uint8_t             phaseL_table[4];
uint8_t             phaseR_table[4];

/* 2상 여자제어방식 모터 제어 함수를 export */
```

- main.c

```C
#include "motor-v1.h"
// #include "motor-v2.h"
```

이런식으로 한 파일에 여러 로직을 담는 것이 아닌, 파일을 분리하는 것이 더 나은 설계라고 생각합니다. 즉, 기존에는 테스트를 하기 위하여, 여러 파일을 찾아다니며 여러 주석을 변경해야했지만, 개선 후에는 main.c의 주석 한줄만을 변경하면 됩니다. (의존성 주입 만세! 클린 아키텍쳐 만세!)

여담으로 1-2상 여자제어와 2상 여자제어 중에 어떤 방식을 채택했냐하면, 성능 차이가 별로 없어 보여서 1-2상 여자제어 방식을 선택했습니다. 결국 레거시를 선택한 것이죠. 그렇다면 이런 노력은 의미가 없는 것일까요? 아닙니다. 1-2상 여자제어에서 2상 여자제어로 변경하니, 제어 주기가 늘어남에 따라 모터의 구동음이 기존보다 낮은 소리로 들렸습니다. 그리고 제어 주기가 달라짐에 따라 소리의 음이 변화했던 경험을 바탕으로, 추후 DC 모터를 활용한 라인트레이서에서 치명적인 문제를 해결할 수 있었습니다. 정말 쓸데 없는 경험처럼 보이지만 이런 사소한 경험이 도움이 되는 경우도 있더군요. DC 라인트레이서와 관련한 문제해결 경험은 추후 포스팅에서 다뤄볼 예정입니다.

## 5. 나오며

지금까지 STEP 라인트레이서를 소개하고, 모듈화, 성능 향상과 테스트, 의존성 주입에 대한 저의 인사이트를 공유해보았습니다. 저의 경우, 임베디드 소프트웨어에서 배운점이, 높은 레벨의 개발을 더욱 깊게 이해할 수 있는 밑거름으로 작용한 것 같습니다. STEP 라인트레이서는, 제가 개발을 시작하고 처음으로 대회에 나가 평가받은 프로젝트여서, 특별한 애착이 있는 것 같습니다. 이러한 STEP 라인트레이서를 소개하고, 관련한 저의 통찰을 소개할 수 있어 기쁩니다. 이만 글을 줄여보겠습니다.

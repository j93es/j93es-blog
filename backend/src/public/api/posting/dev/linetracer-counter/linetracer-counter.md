---
title: 라인트레이서 계수기 소프트웨어
date: 2025-03-11 16:21
tag: [Embedded, Frontend, Backend]
category: dev
description: "계수기 소프트웨어를 개발에서 학습한 내용, 기술적인 고민과 어떻게 개선할 수 있을지에 대한 생각을 소개하려합니다."
---

## 목차

0. 들어가며
1. 프로젝트 소개
2. 관리자 프론트엔드
   - 페이지 소개
   - Web Serial API
   - 컴포넌트 재사용성
   - 디테일의 미학 - 타이머 숫자
3. 관리자 백엔드
   - DB schema 설계
   - Repository, Service
   - JWT Auth
   - SSE
   - MongoDB의 \_id
4. 참가자 프론트엔드
   - 페이지 소개
5. 참가자 백엔드
   - Polling, Caching 전략
6. 나오며

## 0. 들어가며

라인트레이서 계수기 소프트웨어와 관련한 포스팅은 2편에 나누어 게시할 예정입니다. 첫번째 포스팅은 프로젝트를 소개하고, 구현과정에서 학습했던 지식을 정리하며, "지금이라면 이렇게 설계하겠다" 등의 내용을 담겠습니다. 두번째 포스팅은 실제 서비스를 배포할 때, 실수했던 점/아쉬웠던 점/좋았던 점을 정리하고 성찰하는 시간을 가지려합니다.

이번 포스팅은 2024 전국라인트레이서 경연대회에서 활용한 계수기 소프트웨어 개발 과정에서의 경험을 소개하고자합니다. 첫째로 프로젝트에 대해 소개하며, 어떤 구성요소가 있는지, 어떻게 상호작용하는지를 살펴보겠습니다. 둘째로, 각 구성요소를 구현하며 학습한 지식을 정리하고, "지금이라면 이렇게 설계하겠다" 등의 생각을 공유하겠습니다.

## 1. 프로젝트 소개

라인트레이서 경연대회는 라인트레이서라는 로봇의 주행시간으로 순위가 결정됩니다. 이때, 로봇의 주행기록을 측정하는 기계를 통칭 계수기라고 표현합니다. 이때, 계수기는 하드웨어와 소프트웨어로 구성됩니다.

하드웨어는 각종 센서를 활용하여, 로봇이 출발/도착 여부를 확인하고, 최종적인 주행시간을 측정하는 등의 역할을 합니다. 하드웨어는 로봇이 출발했을 때, 로봇이 도착했을 때, 최종 주행시간이 산출되었을 때, 소프트웨어에 신호를 전달합니다. 더하여 소프트웨어에서 리셋 신호를 보내면, 로봇의 출발을 기다리는 상태로 진입해야합니다.

소프트웨어는 하드웨어로부터 받은 신호를 바탕으로, 여러 정보를 관리하며, 대회 전광판의 정보를 실시간으로 업데이트해야 합니다. 더하여 하드웨어에 리셋신호를 전달할 수 있어야합니다.

더하여 대회장의 전경은 다음과 같습니다.

<img src="/api/posting/dev/linetracer-counter/img/대회장-구조.jpg" alt="대회장 구조" width="600" height="423.5" loading="lazy">

이때, 계수기 하드웨어와 소프트웨어는 시리얼 통신으로 연결됩니다. 더하여 계수기를 관리하는 곳과 전광판을 관리하는 곳이 멀리 떨어져있었기 때문에, 유선이 아닌 무선 통신 수단을 이용해야했습니다. 저는 웹기술로 계수기 소프트웨어를 구현하였습니다.

먼저, 참가자/주행기록 등의 정보를 관리하는 백엔드를 구현하였습니다. 다음으로 관리자 프론트엔드를 구현하였습니다. 관리자 프론트엔드는 관리자 인증을 위한 로그인 페이지, 계수기 하드웨어와 시리얼 통신이 가능하고 서버의 정보를 업데이트할 수 있는 정보 관리 페이지와, 계수기 관리자 페이지에서 업데이트된 정보를 실시간으로 반영하는 전광판 페이지로 구분됩니다.

더하여 저는 참가자들의 자신의 순위와 경연 순서를 확인할 수 있는 웹 서비스가 있다면, 참가자의 만족도가 올라갈 것이라 판단하였습니다. 기존에는 참가자의 참가순서나 순위를 전광판에서 확인할 수 있었지만, 전광판에서는 극히 일부의 참가순서나 순위만을 포함할 수 있습니다. 정보를 전광판만으로 송출하는 것은 참가자 만족도에 영향을 미칠 수 있습니다. 예를들어, 본선은 상위 10등까지 진출하지만, 전광판에서는 상위 3등의 정보만 송출하여, 자신의 본선진출 여부를 실시간으로 확인하기 어렵습니다. 더하여 참가 순서는 전광판에 현재 경연 진행자와 그 다음 경연 진행자만 표시되어, 참가자는 자신의 경연순서를 실시간으로 알기 어렵습니다. 이에 대회 참가자의 만족도를 위하여, 참가순서와 순위정보를 제공하는 백엔드와 참가자 프론트엔드를 구현하였습니다.

다음은 전체적인 구조를 도식화한 것입니다.

<img src="/api/posting/dev/linetracer-counter/img/도식도.jpg" alt="도식도" width="600" height="337.5" loading="lazy">

지금부터는 제가 계수기 소프트웨어를 관리자 백엔드/프론트엔드, 참가자 백엔드/프론트엔드로 나누고, 각 부분을 설계/구현하며 고민했던 지점과 학습한 개념을 소개해보려합니다.

## 2. 관리자 프론트엔드

### 페이지 소개

지금부터는 관리자 프론트엔드에 대해 설명하려 합니다. 관리자 프론트엔드는 3개 정도의 페이지로 나눌 수 있습니다.

첫째로 로그인 페이지는 토큰을 서버로 요청하는 역할을 합니다. 보안적인 측면을 고려하여, 프론트엔드에서 토큰에 대한 로직을 최소화하였습니다.

<img src="/api/posting/dev/linetracer-counter/img/로그인-페이지.jpg" alt="로그인 페이지" width="594" height="461" loading="lazy">

둘째로 정보를 관리하는 페이지는 경연, 참가자, 부문, 경연타이머, 경연기록, 계수기 하드웨어와의 시리얼통신 등 정말 많은 정보를 다루어야했습니다. 이 페이지를 구성하며 기획과정에서의 기능명세, 페이지 명세 등의 필요성을 뼈져리게 느꼈습니다. 복잡하고 다양한 로직을 다룰수록, 명세는 선택이 아닌 필수가 되는 것 같습니다.

<img src="/api/posting/dev/linetracer-counter/img/정보-관리-페이지.jpg" alt="정보 관리 페이지" width="476" height="590" loading="lazy">

셋째로 전광판 페이지는 실시간으로 업데이트되는 정보를 받아오고, 이를 보여주면 됩니다. 이 페이지는 참가자들이 보게되는 페이지이기 때문에, 나름대로 디자인적 요소를 신경쓰며 제작하였습니다.

<img src="/api/posting/dev/linetracer-counter/img/전광판-페이지.jpg" alt="전광판 페이지" width="600" height="489" loading="lazy">

지금까지 각 페이지를 살펴보았습니다. 이후에는 이러한 페이지를 제작하며 학습한 지식과 생각을 공유하겠습니다.

### Web Serial API

Web Serial API는 Web API의 일종입니다. Web Serial API는 웹에서 시리얼통신이 가능하게 만들어줍니다. 하지만 데스크탑 환경의 Chrome, Edge, Opera에서만 사용가능한 제한적 기능입니다. 더욱 자세한 내용은 [MDN 문서](https://developer.mozilla.org/en-US/docs/Web/API/Web_Serial_API)와 [Chrome 문서](https://developer.chrome.com/docs/capabilities/serial?hl=ko)에 더욱 상세히 기술되어있습니다.

이러한 Web API를 사용하며 React의 장점을 실감했습니다. 먼저 Web API 문서의 대부분은 순수 js로 예시를 서술합니다. 이때 React의 장점인 자유도가 높다는 점으로 인하여, 순수 js를 빠르게 React로 포팅할 수 있습니다. 즉, Web API 등의 신기술을 활용할 때에, React의 자유도가 높다는 점은, 개발과정을 단축시킬 수 있다고 생각합니다.

### 컴포넌트 재사용성

컴포넌트 재사용성은 워낙 유명하고, 격언과도 같은 존재입니다. 저의 경우에도 개발과정을 단축시키고, 디자인 통일성을 위하여 컴포넌트를 적절한 단위로 분리하고 재사용하였습니다.

이때, 컴포넌트 재사용성을 위해서는 적절한 단위로 분리하는 것 뿐만 아니라, CSS 요소 또한 신경써야한다는 점을 강조하고 싶습니다. 예를 들어, a라는 컴포넌트가 A의 자식일때는 의도했던 디자인이 나왔지만, B의 자식이 될 경우 글자의 배치가 틀어진다는 등의 현상이 나타날 수 있습니다. 즉 컴포넌트 재사용성을 위해서는, 자식 컴포넌트의 CSS가 부모 컴포넌트의 CSS에 의존해서는 안될 것입니다. 당연하지만 놓칠 수 있는 부분이라 생각하기에 적어보았습니다.

### 디테일의 미학 - 타이머 숫자

웹페이지의 성능 측정 지표 중에 CLS라는 지표가 있습니다. 이는 뷰포트 내의 콘텐츠의 위치가 얼마나 불안정하게 변화하는지를 나타내는 지표입니다.

CLS와 완전히 같은 맥락은 아니겠지만, 타이머 UI의 숫자가 불안정하게 움직인다면, 이는 바람직하지 못하다고 생각했습니다. 예를들어 1:59에서 2:00이 된다면 1과 2의 글자 크기가 다르기 때문에 : 이후의 글자가 움직이게 됩니다. 다시말해, 숫자간의 width가 다르기 때문에, 타이머의 숫자가 변경될 때마다 불안정하게 흔들립니다. 따라서 전광판 페이지의 숫자는 불안정하게 흔들리지 않도록 설계하였습니다.

사실 이는 굉장히 사소한 부분일 것입니다. 하지만 저는 이러한 사소한 디테일이 사용자 경험과 완성도에 영향을 미칠 수 있다고 생각하는 사람입니다. 이러한 디테일을 잘 챙기는 엔지니어로 성장하고자 합니다.

## 3. 관리자 백엔드

간단히 관리자 백엔드의 역할을 설명하려합니다. 관리자 백엔드는 단순한 CRUD와 관리자 인증을 담당하는 역할을 합니다. 관리해야할 정보는 6개 정도가 있었습니다. 경연, 참가자, 참가자별 로봇, 참가자별 부문, 부문별 경연 기록에 대한 CRUD 기능이 필요했습니다. 더하여 관리자 인증을 위하여 JWT 토큰을 발급하고, API 요청에 대해 토큰을 검증하는 로직이 필요했습니다. 이러한 관리자 백엔드를 구현하면서 겪었던 고민과 개선점을 소개해보려합니다.

### DB schema 설계

DB schema(혹은 table) 설계할때는 적절한 추상화, CRUD를 고려한 설계가 중요하다고 생각합니다. 먼저 적절한 추상화를 통하여 각 정보를 명료하고 직관적이게 묶습니다. 더하여 CRUD를 고려해야합니다. 왜냐하면 DB schema 설계는 populate(혹은 join)가 일어나는 빈도를 결정할 수 있습니다. 돌이켜보면 저는 직관적이지 않고, CRUD를 고려하지 않은 DB schema 설계를 했었던 것 같습니다. 저의 기존 DB schema 설계를 살펴보며, 개선책을 제시해보겠습니다.

저는 (1)과 같이 DB schema를 설계했었습니다.

```bash
(1)
└── 경연
    └── [참가자]
        ├── 로봇
        └── [부문]
            └── 경연 기록
```

(1)의 설계는 schema의 depth가 깊습니다. 이는 직관적이지 못하다고 생각하며, CRUD 로직이 복잡해지고, 많은 populate를 유발할 수 있습니다. 참가자가 p개, 각 참가자별 부문이 모두 s개라면, p + (p \* s)번의 populate가 일어납니다. 어떻게 개선할 수 있을까요?

```bash
(2)
└── 경연
    └── [부문]
        └── [참가자 + 로봇 + 경연기록]
```

(2)의 설계는 경연 아래에 부문을 두고, 참가자/로봇/경연기록을 하나의 schema에 때려박는(?) 설계입니다. (2)의 설계는 (1)보다 직관적이고, CRUD 로직이 간단해집니다. 더하여 (2)의 설계는 (1)보다 적은 s + (s \* p)번의 populate가 일어납니다.(s는 p보다 작다는 전제하이며, 대회의 특성상 왠만해선 참입니다.)

사실 (1)로 설계한 이유는 중복된 정보를 줄이기 위함이었습니다. 먼저, 참가자의 정보는 부문 정보보다 큽니다. (1)의 설계는 부문 정보가 중복되고, (2)의 설계는 참가자의 정보가 중복됩니다. 즉, (2)의 설계는 중복된 정보가 더 많아집니다.

하지만 프로젝트를 진행하다보니, model의 depth가 깊어지며, CRUD 자체가 매우 복잡해졌습니다. 더하여 populate도 많이 필요해지며 성능에 대한 이슈를 자연스레 고민하게 되더군요. 지금의 저라면 정보의 중복을 감수하고서라도, schema의 depth를 얕게 유지하는 선택을 하겠습니다.

(다만 DB schema 설계를 변경하여 populate 개수가 줄어든다고 하여도, 성능에 크게 영향이 없을 수도 있겠습니다. 이는 부하테스트로 확인해야하는 영역이며, 추후 기회가 된다면 해보도록 하겠습니다.)

### Repository, Service

위와같은 끔찍한 DB schema 설계로 인하여 데이터베이스에 접근하는 로직이 매우 방대해졌습니다. 이러한 혼돈 속에서 repository와 service를 나누어두었기에 프로젝트를 마무리할 수 있지않았나 싶습니다. 지금부터 Repository, Service에 대해 살펴보겠습니다.

Repository는 데이터의 접근을 추상화한 계층입니다. 데이터베이스 접근 등을 Repository에서 수행합니다. 다음으로 Service는 비즈니스 로직을 담당합니다. Service는 Repository에서 받아온 정보를 비즈니스 로직에 맞게 가공하여 반환합니다.

그렇다면 Repository, Service를 나누는 것은 어떤 이점이 있을까요? 먼저 데이터베이스와 관련한 로직이 응집되고, 비즈니스 로직과 관련한 로직이 응집된다는 것 자체로 장점입니다. 이는 유지보수성을 높이는 데에 기여합니다. 더하여 하나의 Repository를 여러 Service에서 사용하며, 재사용성이 높아질 수 있습니다. 더하여 의존성 주입으로 인하여 테스트가 간편해질 수 있습니다. 이외에도 여러 장점이 있습니다. 간단한 서비스에서 복잡한 서비스로 전환된다는 느낌이 든다면 Repository, Service를 나눌때가 온 것일지도 모릅니다.

그런데 Repository, Service는 어떻게 구현해야할까요? 적절히 구현하지 못하여, 의존성 주입의 장점을 살릴 수 없거나, 비즈니스 로직과 데이터베이스 로직이 명확히 구분되지 않는다고 생각하시는 분들도 계실겁니다.(저도 그랬습니다.) 이와 관련하여 추후에 포스팅을 작성해보겠습니다.

(허나 지금 당장 필요하신 분이라면, 제가 계수기 프로젝트를 발판삼아 진행한, [창의공학설계 경진대회 프로젝트](https://github.com/j93es/2024-creative-engineering-design-competition.git)에서 backend/src/core를 중심으로 backend/src/service, backend/src/repository를 살펴보시길 바라겠습니다. core에서 작성한 interface를 실제 repository와 service 코드에서 어떻게 implement하여 사용하는지, backend/src/service/index.ts와 backend/src/repository/index.ts에서 어떻게 export 하는지에 집중하시길 바라겠습니다.)

### JWT Auth

인증을 구현할때 어떤 방법을 활용할 수 있을까요? 먼저 사용자 별로 다른 key 값을 주고, Header에 이를 포함하여 요청하고 서버는 key가 있는지 확인하는 방법이 떠오릅니다. 하지만 사용자의 수가 매우 많아진다면 key를 저장하는 공간이 매우 아깝겠죠. 이에 JWT의 인증방식이 등장했습니다. JWT 인증방식에 대해 알아봅시다.

JWT는 3가지의 부분으로 나눌 수 있으며 이는 "."으로 구분됩니다.

```bash
{header}.{payload}.{signature}
```

header에는 토큰 타입, 서명 알고리즘이 포함됩니다. payload에는 토큰의 발급시간, 만료시간, 권한 등이 포함될 수 있습니다. signature는 header와 payload를 미리 지정한 secretKey로 암호화하여, 토큰의 유효성을 검증할때 사용합니다.

그런데 토큰이 탈취당할 염려가 있진 않을까요? 만약 토큰이 탈취당하면, 유효기간이 만료되기 전까지 해커의 칼춤이 시작될 것입니다. 그렇다면 해결방법은 토큰의 유효기간을 짧게 잡는 것이 생각납니다. 하지만 너무 잦은 로그인이 필요하게 되며, 사용자 경험을 해칠 수 있습니다.

이에 RefreshToken과 AccessToken을 구분하여 발급합니다. 기본적인 인증은 짧은 유효기간을 지닌 AccessToken이 담당합니다. 즉, AccessToken이 탈취되어도 짧은 시간의 유효기간이기에, 실질적인 해킹 피해를 최소화할 수 있게됩니다. 이때 AccessToken이 만료되면 RefreshToken으로 다시 요청을 보냅니다. RefreshToken은 긴 유효기간을 가지고 있으며, AccessToken을 다시 발급받기 위한 수단입니다. 여기에서 중요한 것은 RefreshToken은 AccessToken보다 탈취당할 확률이 적다는 것입니다. 왜냐하면 AccessToken은 거의 항상(비즈니스 로직에 따라 다르겠지만) 포함되지만, RefreshToken은 AccessToken이 만료되었을때만 포함되기 때문에, 요청에 포함되는 빈도자체가 줄어들고 탈취당할 확률이 적어집니다.

정리하면, 탈취당하더라도 유효기간이 짧기때문에 해킹 피해를 최소화할 수 있는 AccessToken을 중심으로 인증을 진행합니다. 더하여 AccessToken이 만료되었을때만, 유효기간이 길고 탈취 확률이 적은 RefreshToken으로 AccessToken을 다시 발급합니다.

(더하여 (아주 당연한 이야기지만) 토큰은 무조건 백엔드에서 다뤄야합니다. 프론트엔드는 토큰을 발급받고, 요청을 할 때 발급된 토큰을 포함하여 요청하는 역할만을 해야합니다.)

지금까지 JWT 토큰에 대해 살펴보았습니다.

### SSE

SSE는 단방향 통신의 일종이며, 서버에서 클라이언트에게 정보를 실시간으로 제공하는 기술중 하나입니다. 내부적로 HTTP 프로토콜을 이용하고, HTTP 버전에 따라 연결유지 개수가 달라집니다.[(HTTP/2: 100개, else: 6개)](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) 아래는 통신 방식을 지연시간과 서버부하 측면에서 비교한 표입니다.

| 기술                     | 지연시간  | 서버부하                  |
| ------------------------ | --------- | ------------------------- |
| WebSocket                | 매우 낮음 | 중간 (연결 유지 오버헤드) |
| SSE (Server-Sent Events) | 낮음      | 낮음 (HTTP 사용)          |
| WebRTC                   | 매우 낮음 | 낮음                      |
| Long Polling             | 중간      | 높음                      |
| Polling                  | 높음      | 매우 높음                 |

먼저 저의 프로젝트는 단방향으로 정보를 전송하면 되는 상황이었고, 실시간성은 SSE로도 충분했으며, 서버부하 측면에서 SSE가 우수했으며, 소켓은 인프라 환경을 고려해야하지만 SSE는 HTTP로 동작하기에 이식성이 좋을 것으로 판단하여 SSE를 선정하였습니다. 도구 자체에 대한 지식도 중요하지만, 여러 도구 중 가장 적합한 도구를 가치판단하여 선정하는 것의 중요성을 간과해서는 안되겠습니다.

더하여 SSE를 적용하기 위해서는 정보가 업데이트 되었는지 서버에서 확인하고, 업데이트 되었다면 클라이언트에게 정보를 보내야합니다. 즉, Router/Middleware를 설계할 때 있어서, 변경점을 효율적으로 판별하기 위한 설계가 중요합니다. 저의 경우에는 정보가 업데이트되는 Router로 요청(POST, PATHCH 등)이 들어온다면, Router의 요청이 종료되기 직전, SSE 관련 함수를 호출하여, 클라이언트에게 정보를 송출했습니다. 지금 생각하면 각 Router에서 함수를 호출하는 것이 아닌, Middleware로 깔끔하게 묶는 것이 좋아보이긴 합니다. 혹은 ETag를 통하여 관리하는 방법도 있겠습니다. 하지만 이 부분에 대해서는 여전히 최선의 방법이 무엇인지 고민하는 중입니다. 정리하면 SSE를 활용하기 위해서는, 정보 업데이트 판별이 효율적이고 직관적으로 이루어지는 Router/Middleware 설계가 필요합니다.

### MongoDB의 \_id

MongoDB는 저장된 도큐먼트에 대해 \_id를 생성하며 이는 ObjectId에 해당됩니다.

그런데 \_id를 ObjectId로 사용하는것이 타당한가에 대해 의문이 들었습니다. [MongoDB 문서](https://www.mongodb.com/ko-kr/docs/manual/reference/method/ObjectId)에는 ObjectId와 관련한 내용이 나옵니다. 이는 string과는 다르며, .toString 메서드를 통하여 문자열로 활용할 수 있습니다. 이때, 백엔드에서 프론트엔드로 ObjectId를 보낼때 text로 변환하는 과정에서 .toString 메서드가 호출되어, 프론트엔드는 ObjectId가 아닌 string을 수신합니다. 그리고 프론트엔드에서 id로 정보를 조회하기 위하여 백엔드로 요청을 보내면, 백엔드가 DB에 요청할때 id를 ObjectId로 변환해야합니다.

id에 대한 로직을 MongoDB에 일임하기보다는, backend에서 관리하는 것이 타당하다고 판단하였습니다. 왜냐하면 id를 변환하는 과정 자체가 번거롭기도 하고, 추후 MongoDB에서 다른 DB로 변경할때 id에 대한 로직이 변경되는 것은 클린한 아키텍쳐가 아니라고 생각하기 때문입니다.

따라서 저는 MongoDB의 \_id 필드에 ObjectId를 활용하는 것이 아닌, uuid 혹은 nanoid를 활용하여 id 로직을 관리하였습니다.

여담으로 관리자가 아닌 사용자 등 \_id와 id가 필요하지 않은 사용자에게 이러한 정보를 제공할 필요는 없다고 생각합니다. 더 나아가 \_id와 id 뿐만 아니라, 정보를 사용할 사용자 별로 정보 제공 범위를 지정하는 것 또한 중요하겠습니다.

## 4. 참가자 프론트엔드

### 페이지 소개

이제부터는 참가자 프론트엔드에 대해 논해볼 예정입니다. 해당 페이지는 대회 참가자가 자신의 순서와 순위를 확인할 수 없다는 불편함을 극복하기 위하여 기획하였습니다. 로직은 단순했으나, 디자인이나 디테일을 더 챙기지 못한 것이 너무나 아쉽습니다. 지금부터는 각 페이지를 살펴보겠습니다.

참가자가 도메인에 접근했을때, 처음으로 접하는 페이지입니다. 해당 페이지는 대회 정보와 축사 등 기본정보를 담도록 구성하였습니다.

<img src="/api/posting/dev/linetracer-counter/img/참가자-홈.jpg" alt="참가자 홈" width="517" height="570" loading="lazy">

참가자가 실시간으로 경연기록을 확인하고, 순서에 대한 정보를 제공하는 페이지입니다.

<img src="/api/posting/dev/linetracer-counter/img/참가자-실시간경연기록.jpg" alt="참가자 실시간경연기록" width="517" height="415" loading="lazy">

감사하게도 대회를 개최함에 있어 많은 후원을 받았습니다. 후원사의 로고를 표출하여, 홍보효과를 극대화하기 위하여 노력하였습니다. 후원사인 MAXON 모터, 몬스터 에너지와 주최와 후원을 해주신 서울시립대학교에 다시금 감사의 말씀 드리고 싶습니다.

<img src="/api/posting/dev/linetracer-counter/img/참가자-후원.jpg" alt="참가자 후원" width="517" height="573" loading="lazy">

## 5. 참가자 백엔드

참가자 백엔드 또한 로직이 간단합니다. DB에서 전체 정보를 받아오고, 사용자의 요청이 오면 정보를 전송하기만 하면 됩니다. 다만, 많은 요청으로 인하여 서버 부하가 늘어나는 것을 방지하려하였습니다.

### Polling, Caching 전략

참가자 페이지는 참가자에게 순위와 순서를 제공하는데에 그 목적이 있습니다. 이러한 서비스를 지연시간이 없는 실시간 서비스로 구현하기에는 무리가 있다고 판단하였습니다. 100명 정도가 참가하는 대회에서 모든 참가자에 SSE로 연결하거나 소켓으로 연결을 유지하기에는 서버 부하에 있어 좋지 않다고 판단하였습니다.

이에 저는 10초 정도의 지연시간을 상정하고, 백엔드에서 DB로 5초에 한번씩, 프론트엔드에서 백엔드로 5초에 한번씩 Polling으로 정보를 업데이트 하기로 하였습니다. 이렇게 구성한다면 프론트엔드에서는 최대 10초의 지연시간을 가지게 됩니다.

이러한 Polling을 통한 정보 업데이트 로직이 확정되었다면, Caching을 적용하는 것은 아주 쉬워집니다. 백엔드에서 5초에 한번씩 정보를 받아온다면 5초간 정보를 Caching하면 됩니다. Caching의 목적은 궁극적으로 메모리를 활용하여 리소스를 아끼는 데에 있습니다. 서비스 로직에 따라 적절한 Caching 전략을 수립하는 것은 매우 중요할 것입니다.

정리하면, 서비스의 요구사항과 서버 부하를 고려하여 Polling을 활용하였고, 서비스 로직을 고려한 Caching 전략을 수립하였습니다.

## 5. 나오며

지금까지 계수기 소프트웨어를 개발하며 학습한 내용과 기술적인 고민을 소개해봤습니다. 관리자 프론트엔드와 관련하여 Web Serial API를 적용하며 깨달은 React의 장점, 컴포넌트 재사용성을 높이기 위한 CSS 설계, UI 디테일을 챙기는 것의 중요성을 살펴보았습니다. 관리자 백엔드에서는 DB schema 설계, Repository/Service, JWT Auth, SSE, MongoDB의 \_id를 살펴보았습니다. 마지막으로 참가자 프론트엔드 페이지들을 소개하고, 백엔드와 관련하여 Polling/Caching 전략을 공유해봤습니다.

그런데 대회 당일 이 서비스는 깔끔하게 동작하지 못하였습니다. 다음 포스팅에서는 "왜 깔끔하게 동작하지 못하였는지?" "어떤 점이 아쉬웠는지?" "그럼에도 불구하고 어떤 점이 좋았는지?" 등의 피드백을 가져볼 예정입니다.

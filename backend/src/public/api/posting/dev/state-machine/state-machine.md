---
title: "State Machine"
date: 2025-01-12 20:49
tag: [Embedded, JavaScript]
category: dev
description: "상태를 관리하기 위한 설계 방식 중 하나인 State Machine이, 임베디드/JavaScript에서, 어떻게 활용되는지 살펴보겠습니다."
---

## 목차

0. 들어가며
1. State Machine이란?
2. State Machine과 STEP 라인트레이서
3. State Machine과 JavaScript의 비동기 함수
4. 나오며

## 0. 들어가며

이번 글은 State Machine을 중심으로 진행됩니다. 첫째로 State Machine을 소개하겠습니다. 둘째로 STEP 라인트레이서를 제작하며 State Machine을 어떻게 활용했는지 살펴보겠습니다. 셋째로 JavaScript 비동기 함수를 구버전 문법으로 변환시킨 결과를, State Machine을 중심으로 이해해보겠습니다. 임베디드 소프트웨어에서 학습했던 State Machine이, JavaScript 비동기 함수의 이해를 도왔다는 점을 짚는 것을 마지막으로 글을 마치려 합니다.

## 1. State Machine이란?

본론에 앞서 State Machine에 대한 간단한 설명이 필요할 것 같습니다. State Machine은 상태를 관리하기 위한 설계 방식 중 하나입니다.

그런데 상태 관리란 정확히 무엇을 의미할까요? 예를 들어보겠습니다. 저는 지금 퇴근길에 있다고 가정해보겠습니다. 회사에서 집까지는 하나의 횡단보도가 있습니다. 그렇다면 저의 퇴근길은 다음의 상태들로 나타내볼 수 있을 것입니다.

1. 퇴근시간까지 회사에서 대기 상태(IDLE)
   - 퇴근시간이 되면 다음 상태로 넘어감
2. 횡단보도로 이동하는 상태
   - 횡단보도에 도착하면 다음 상태로 넘어감
3. 초록불을 대기하는 상태
   - 초록불이 되면 다음 상태로 넘어감
4. 집으로 이동하는 상태
   - 집에 도착하면, 다음날 다시 회사에 가서 퇴근시간까지 기다림(IDLE 상태로 돌아감)

예시에서 각 상태는 어떤 조건이 충족되면 다음단계로 넘어갑니다. 이처럼 행위를 단계별로 나누고 각 상태를 관리하는 것이 State Machine의 핵심 개념입니다. 그렇다면 이렇게 상태를 관리하는 것은 어떤 이점을 불러올까요? 여러 이점이 있지만, 이번 글에서는 '에러 처리', '비동기 처리'와 관련한 이점 대해 다뤄볼까 합니다.

처음으로 '에러 처리'와 관련한 이점에 대해 살펴봅시다.

저는 횡단보도로 이동하는 상태에 있었습니다. 그런데 갑자기 상사가 "내가 매우 적적하네"라고 말하며 회사로 복귀하라 하네요? 이건 에러죠... State Machine과 함께라면 저는 회사로 복귀하는 상황을 더욱 자세히 로깅할 수 있습니다. 예를들어 "횡단보도로 이동하다가 상사가 회사로 부름" 이런식으로 말이죠. 단순히 "상사가 회사로 부름"으로 로깅을 하기보다는, 어느 상태에서 에러가 났다고 로깅하는 것은 추후 에러를 다루는데에 있어 중요한 요소일 것입니다. 이처럼 State Machine은 에러를 기록하고 처리하는 데 유용하게 활용될 수 있습니다.

다음으로 '비동기 처리'와 관련한 이점 대해 알아봅시다.

먼저 State Machine을 활용하지 않는다고 가정해봅시다. 저는 초록불을 기다리고 있었습니다. 그런데 저는 기다리는 시간이 너무 아까운 나머지 핸드폰을 보고싶습니다. 그런데 핸드폰을 본 순간 저는 상태를 기억하지 않았기 때문에 초록불을 기다리고 있던 것을 까먹습니다. 따라서 퇴근 시간이 지났는지, 횡단보도에 도착했는지를 순차적으로 확인하고 나서야 지금 내가 초록불을 대기하는 상태인 것을 인지하게 됩니다. 즉, 불필요한 과정이 너무나 많이 생깁니다.

한편, 이러한 불필요한 과정을 줄이기 위하여 저는 초록불 기다리는 상태에 온 순간, 다른 활동은 전부 멈추고 초록불이 되기를 하염없이 기다리는 방법을 택할 수도 있을 것 입니다. 그러나 이 방법을 택하면 핸드폰을 못하게 되며 시간을 허비하게 됩니다.

이러한 비효율을 줄이기 위해 State Machine을 활용할 수 있습니다. 마찬가지로 저는 초록불을 대기하는 상태에 있었습니다. 저는 초록불을 기다리는 동안 핸드폰으로 다른 작업을 합니다. 그리고 내가 초록불을 기다리고 있는 상태라는 것을 기억합니다. 이렇게 하면 핸드폰을 보면서, 기억한 상태를 기초로 중간중간 초록불이 됐는지 확인할 수 있습니다. 이처럼 저는 핸드폰을 하며, 초록불을 대기하는 2개의 작업을 효율적으로 함께 처리할 수 있습니다. 즉, a와 b라는 작업을 둘 다 수행해야할 필요가 있을 때, 상태를 기억함으로써, 불필요한 연산을 최소화할 수 있습니다.

- State Machine 활용 시 => 2개의 작업을 효율적으로 함께 처리 가능

  1. 초록불인지 확인
  2. 핸드폰을 봄
  3. 초록불인지 확인
  4. 핸드폰을 봄

- 상태 저장을 안했을 시 => 비효율적

  1. 퇴근시간인지 확인(필요없는 연산)
  2. 횡단보도에 도착했는지 확인(필요없는 연산)
  3. 초록불인지 확인
  4. 핸드폰을 봄

- while문으로 block 시 => 2개의 작업을 함께 처리 불가능

  1. 초록불로 바뀔 때까지 대기
  2. 핸드폰을 봄

지금까지 State Machine의 개념과 사용하였을 때 기대할 수 있는 효과에 대해 살펴보았습니다. 간단히 요약하면, State Machine은 상태를 관리하기 위한 설계방식 중 하나입니다. 더하여 State Machine을 활용했을때 에러 처리, 비동기 처리 측면에서 이점을 기대해볼 수 있습니다. 지금부터는 State Machine이 STEP 라인트레이서에 적용된 사례를 소개해볼까 합니다.

## 2. State Machine과 STEP 라인트레이서

다른 개발과 비교하면, 임베디드 소프트웨어 개발은 불필요한 연산을 줄이는 최적화가 더욱 필요합니다. 더하여 라인트레이서의 경우 로봇의 상태를 파악함과 동시에 주행 전략을 선택하는 등의 여러 작업을 함께 처리해야 합니다. 또한 대부분의 임베디드 소프트웨어는 싱글 스레드 환경에서 동작합니다.

이러한 특징 때문에 STEP 라인트레이서 제작에서는 여러 작업을 효율적으로 처리하기 위해 State Machine이 활용됩니다. 먼저 저의 라인트레이서는 기록 단축을 위하여 직선에서 가속을 할 수 있도록 설계하였습니다. 이때 직선에서 가속하는 작업을 함과 동시에, 마크를 판단한다던지, 로봇에 이상이 없는지 등의 작업을 함께 처리하는 것이 필요한 상황이었습니다. 이에 직선에서 가속하는 작업을 직선에서 가속을 기다리는 상태, 감속을 기다리는 상태, 직선 가속이 종료된 상태 등으로 나눈 후 State Machine으로 설계하였습니다. 다음은 제가 STEP 라인트레이서를 제작하며 작성한 코드를 재구성한 것입니다.

```c
void Straight_Boost() {
    static uint8_t starightBoostCntl = BOOST_CNTL_IDLE;

	// 직선 가속 시퀀스
	switch (starightBoostCntl) {

        // IDLE, 가속 시퀀스 진입 대기 상태
        // 가속 시퀀스 진입 조건을 충족했다면 가속 시작
        case BOOST_CNTL_IDLE :
            if (가속 시퀀스 진입 여부 판단) {
                /* 생략 */
                starightBoostCntl = BOOST_CNTL_DECELE;
            }
            break ;

        // 감속 시작을 기다리는 상태
        // 감속 지점에 도달하였다면 감속 시작
        case BOOST_CNTL_DECELE :
            if (감속 지점에 도달 여부 판단) {
                /* 생략 */
                starightBoostCntl = BOOST_CNTL_END;
            }
            break ;

        // 직선 가속 시퀀스 종료 여부를 기다리는 상태
        // 직선 가속 시퀀스가 종료되었다면 IDLE 상태로 돌아감
        case BOOST_CNTL_END :
            if (직선 가속 시퀀스 종료 여부 판단) {
                /* 생략 */
                starightBoostCntl = BOOST_CNTL_IDLE;
            }
            break ;
	}
}
```

실제 구현은 아래와는 매우 상이하지만, 위의 Straight_Boost()라는 함수는 main 문에서 다음과 같이 호출된다고 이해해도 좋습니다.

```c
int main(void) {
    while(1) {
        Judge_Mark(); // 마크를 판단하는 함수 => State Machine으로 설계함
        Is_Robot_Ok(); // 로봇의 정상 여부 탐지 함수 => State Machine으로 설계함
        Straight_Boost();
    }
}
```

이때 마크를 판단하는 함수, 로봇 이상 탐지 함수 또한 State Machine으로 구현되어 있습니다. 즉, Straight_Boost()라는 함수는 Judge_Mark()와 Is_Robot_Ok()라는 함수의 작업과 함께 실행될 수 있습니다. 이때 상태를 저장해둠으로써, 감속 여부를 판단할 때에, 가속 여부를 판단하는 등의 비효율적인 동작을 최소화할 수 있습니다. 로봇이 직선 가속 종료 중인 상황임을 가정했을때, State Machine 활용 여부로 인하여 달라지는 작업량을 아래에 제시하겠습니다.

- 상태 저장을 안했을 때의 작업량

  1. Judge_Mark() 실행
  2. Is_Robot_Ok() 실행
  3. 가속 시퀀스 진입 여부 판단(필요 없는 연산)
  4. 감속 지점에 도달 여부 판단(필요 없는 연산)
  5. 직선 가속 시퀀스 종료 여부 판단(필요한 연산)

- State Machine 활용 시 작업량

  1. Judge_Mark() 실행
  2. Is_Robot_Ok() 실행
  3. 직선 가속 시퀀스 종료 여부 판단

이러한 State Machine의 개념을 라인트레이서를 만들며 동아리 선배님들을 통하여 학습할 수 있었습니다. State Machine에 대한 이해는 추후 JavaScript의 비동기를 심도있게 이해하는 것에 도움을 주었습니다.

## 3. State Machine과 JavaScript의 비동기 함수

우리는 async, await에 대하여 학습할때, 비동기적으로 동작하며 다른 작업과 함께 처리될 수 있다는 것을 학습합니다. 조금 더 깊게 들어가면 Call Stack, Micro-task Queue, Macro-task Queue와 Event Loop를 살펴보기도 합니다. 저 또한 이 정도의 지식을 학습하였고, 비동기 함수의 개념을 추상적으로만 이해하고 있었습니다.

그런데 바야흐로 약 1년 전, 저를 포함한 3명이 JavaScript 스터디를 할 때에, 한 친구가 async는 어떻게 동작하는지에 대해 호기심을 가졌습니다. 특히 ”어떤 방법으로 해당 작업이 완료될 때까지 기다리는가?“에 초점을 맞췄습니다. async는 어떤 방법으로 동작할까요? 1년 전 스터디에서는 현대 JavaScript를 ES5등의 구버전 문법으로 변환하는 것으로 그 해답에 근접했습니다. 이를 같이 살펴봅시다.

저는 이제 JavaScript는 모르고 TypeScript만 아는 개발자이기 때문에(농담입니다.) TypeScript를 ES5 문법으로 바꾸어 보겠습니다. 참고로 TypeScript는 빌드 시에 JavaScript로 변환됩니다. 런타임 환경에서, 만약 브라우저가 해당 버전의 JavaScript 문법을 지원하지 않는다면, babel과 같은 컴파일러를 통하여, ES5 등의 구버전 문법으로 변환됩니다.

본론으로 돌아와서 저희는 JavaScript의 비동기 함수를, babel을 통하여 ES5 문법으로 변환하여 살펴볼 것입니다. [타입스크립트 to ES5 변환 사이트](https://www.typescriptlang.org/play)에 접속한 뒤, TS Config 탭을 클릭하여 Target 버전을 선택하면 손쉽게 변환이 가능합니다. 아래는 변환 전 코드입니다.

```TypeScript
async function fetchData(): Promise<any> {
  const response = await fetch("https://j93.es");
  return response.json();
}
fetchData().then(console.log);
```

그리고 다음은 변환 후 코드의 일부입니다.

```JavaScript
"use strict";
/* 생략 */
function fetchData() {
  return __awaiter(this, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          // 1) fetch 호출
          return [4 /*yield*/, fetch("https://j93.es")];
        case 1:
          // 2) 응답을 받아서 response 변수에 저장
          response = _a.sent();
          // 3) response.json() 결과(실제 데이터) 반환
          return [2 /*return*/, response.json()];
      }
    });
  });
}
/* 생략 */
```

\_\_generator와 \_\_awaiter라는 헬퍼함수는 구현이 복잡하기에, 간단한 설명만을 제시해보겠습니다. \_\_generator 헬퍼함수는 State Machine을 활용하여 비동기에 대한 실질적인 로직을 처리하는 함수입니다. 다음으로 \_\_awaiter 헬퍼함수는 \_\_generator 헬퍼함수를 이용하여 fetch 등의 비동기 함수를 Promise로 동작시키는 함수입니다. 위의 코드를 분석해보면 일단 fetch 작업을 0번 상태에서 기다립니다. 이후 fetch에서 반환된 Promise가 resolve되면, 헬퍼함수를 통하여 1번 상태로 넘어갑니다. 마지막으로 response.json()의 결과를 반환합니다.

이때 State Machine을 활용하지 않았다면, 0번 상태에서 while문으로 blocking하여 fetch 함수의 응답을 기다려야할 것입니다. 이렇게 구현했다면 JavaScript는 싱글 스레드로 동작하기 때문에, while문으로 blocking하는 동안에는 다른 작업을 수행하지 못할 것입니다. 이는 굉장한 자원낭비일 것입니다. 하지만 State Machine을 활용하여 상태를 저장해둔다면, 비동기 함수를 중지하고 다른 작업을 수행할 수 있습니다. 원활한 이해를 위하여 아래에 간단하게 State Machine 활용 여부에 따른 작업처리 순서를 적어보겠습니다.

- while문으로 block 시 작업처리 순서

  1. fetch 요청 시작
  2. while문으로 응답 대기
  3. fetch 응답 반환
  4. 다른 작업 수행

- State Machine 활용 시 작업처리 순서

  1. fetch 요청 시작
  2. 0번 상태에서 응답 대기
  3. 다른 작업 수행
  4. 1번 상태에서 fetch 응답 반환

즉, State Machine을 활용하면 await을 만나면 실행을 중단하고, Promise가 resolve되면 중단된 지점부터 다시 실행할 수 있습니다. 더하여 Promise가 resolve될 때까지 다른 작업을 멈추고 기다리는 것이 아닌, 멀티 스레드"처럼" 작업을 처리할 수 있습니다.

정리하면 async는, babel을 통하여 ES5 문법으로 변환하였을때, State Machine으로 구현됩니다. State Machine을 통하여, 싱글 스레드 환경에서 여러 작업을 함께 처리할 수 있습니다. 다만 브라우저에서 현대 문법이 native로 지원되는 경우에, JavaScript가 바이트 코드로 변환된 결과가 State Machine을 이용하는지 여부는 검증되지 않았습니다. 하지만 단순히 ”async 함수 내에서 await가 호출되었을때 기다린다“라고 추상적으로 이해한 것을 넘어서, 동작 원리를 State Machine이란 개념을 통하여 이해해보니, 비동기 함수에 대한 이해를 더욱 높일 수 있었습니다.

## 4. 나오며

JavaScript와 임베디드 소프트웨어는 모두 연산의 최적화가 필요하며, 여러 작업을 함께 처리해야하고, 대부분 싱글 스레드 환경에서 동작합니다. 이러한 공통된 문제 상황으로 인하여 State Machine이 낮은 레벨, 높은 레벨에서 두루 사용되는 것일지도 모르겠습니다. 이렇게 임베디드 소프트웨어를 통하여 학습한 State Machine을 바탕으로, 기존에는 추상적으로 인지하였던 비동기 개념에 대해 조금더 깊은 지식을 얻었던 경험을 소개해봤습니다.

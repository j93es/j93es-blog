---
title: 계수기 소프트웨어 피드백
date: 2025-08-08 22:56
tag: [Frontend, Backend]
category: dev
description: "이번 포스팅은 처음으로 서비스를 제작/배포하실 분들에게 유익한 정보를 담아보았습니다. 계수기 소프트웨어를 제작/배포하며 제가 실수했던 지점을 반추하고, 이러한 저의 반추가 추후 서비스를 제작/배포하실 분들에게 유익한 정보로 다가올 수 있기를 바라겠습니다."
---

## 0. 들어가며

라인트레이서 계수기 소프트웨어와 관련한 2번째 포스팅입니다. 이전 포스팅은 프로젝트를 소개하고, 제작 과정에서 학습했던 지식을 정리하였습니다. 그런데 계수기 소프트웨어는 대회 당일 잘 동작하지 못하였습니다. 이번 포스팅은 이러한 실패를 반추하며, 실제 서비스를 배포할 때 실수했던 점/아쉬웠던 점/좋았던 점을 정리해보겠습니다. 그리고 이러한 저의 반추가 추후 서비스를 제작/배포하실 분들에게 유익한 정보로 다가올 수 있기를 바라겠습니다.

## 1. 실패 원인 분석

제가 개발한 계수기 소프트웨어는 대회 당일 잘 동작하지 못하였습니다. 대회 전날까지 정상적으로 동작하던 프로그램이, 대회 당일 동작하지 않는 경험은 돈주고도 못 살 매우 당혹스러운 경험이라고 생각합니다. 이러한 당혹스러운 문제에 대해 사람은 대개 두 분류로 반응하는 것 같습니다. 문제 이후에, 문제를 외면하는 사람과 문제를 반추하여 개선 지점을 찾는 사람으로 나뉠 수 있는 것 같습니다. 저는 후자였고, 앞으로도 그러하고 싶습니다.

잡담은 여기까지 하고, 정확히 소프트웨어가 어떻게 동작하지 않았는지 상황을 설명해보겠습니다. 계수기 소프트웨어는 관리자 페이지와 대회 전광판 페이지 그리고 참가자 페이지로 구성되어있습니다. 더하여 관리자 페이지와 대회 전광판 페이지는 백엔드 서버를 매개로 실시간으로 통신합니다. 그런데 대회 당일 실시간 통신이 잘 작동하지 않으며, 관리자 페이지의 정보가 대회 전광판 페이지에 실시간으로 반영되지 않는 상황이었습니다.

왜 이러한 문제가 대회 당일에만 발생하였을까요? 이유를 좁혀봅시다.

### DB의 과부하

먼저 인프라와 DB 구성에 대해 살펴볼 필요가 있습니다. 해당 서비스를 배포하려던 시기는 우분투의 새로운 LTS 버전이 출시되던 시기였습니다. 이에 저는 무지성으로 새로운 LTS 버전으로 서버를 구성하였지요. 다음으로 DB는 MongoDB를 사용하기로 하였습니다.

그런데 여기에서 문제가 발생합니다. 새로운 우분투 LTS 버전에서는 배포에 적합한 MongoDB 안정 버전이 아직 출시되지 않았던 것이었습니다. 이번 경험을 통해, 인프라를 결정할 때는 서비스에서 사용하는 기술을 명확히 명세하고, 해당 기술의 안정 버전이 출시되었는지 확인하는 것이 얼마나 중요한지 깨달았습니다.

결국, 새로운 우분투 LTS 버전과 MongoDB 안정 버전 간의 호환성 문제를 해결해야 했습니다. 그 당시 응애 개발자의 해결방법은 MongoDB Atlas를 사용한 것이었습니다. 이 MongoDB Atlas는 온프레미스 환경이 아닌, 즉 자신의 서버에 직접 DB를 두지 않고, 클라우드 기반으로 MongoDB를 관리할 수 있는 서비스입니다. 이러한 MongoDB Atlas를 통하여 문제를 봉합할 수 있었습니다. (지금와서 생각해보면 IaC를 도입하여, 인프라를 비교적 쉽게 갈아끼우는 방법도 해결책이 될 수 있겠네요. 하지만 그 당시의 리소스에서 MongoDB Atlas를 이용하는 것이 최선이었던 것 같습니다.)

하지만 대회 당일 MongoDB Atlas가 문제를 가져왔습니다. 사실 MongoDB Atlas의 문제라기보다는, MongoDB Atlas의 무료 플랜을 과신한 저의 판단이 문제였지요. MongoDB Atlas의 무료 플랜은 제한된 CPU·메모리 리소스를 사용합니다. 즉, 적은 트래픽에서는 잘 작동할 수 있지만, 트래픽이 일정 수준을 넘으면 응답 지연이나 연결끊김 등 정상적으로 동작하지 못할 가능성이 높습니다. 리허설 때는 트래픽이 적었기 때문에, MongoDB Atlas가 오류를 반환하지 않았습니다. 하지만 실제 대회 환경에서는 트래픽이 많았기에, MongoDB Atlas가 오류를 반환하였습니다.

```typescript
export const sseNotifyDisplayBoard = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // DB에서 정보를 수신
    const payload = await displayBoardService.getCurrentContestInfo();

    // SSE 연결된 프론트엔드에 정보 전달
    Object.keys(clients).forEach((key: string) => {
      try {
        clients[key].res.write(`data: ${JSON.stringify(payload)}\n\n`);
      } catch (err) {
        console.error(err);
      }
    });
    next();
  } catch (err) {
    console.error(err);
    next();
  }
};
```

위의 코드는 DB에서 정보를 수신하고, SSE 연결된 프론트엔드에 정보를 전달하는 함수입니다. 즉, `await displayBoardService.getCurrentContestInfo()`에서 발생한 에러로 인하여 정보 전달이 불가능해진 것이 문제 원인이었습니다.

그렇다면 이러한 문제를 예방하기 위해서는 어떻게해야할까요? 바로 부하 테스트를 적극 활용하는 것입니다. 부하 테스트란, 목표 트래픽을 시스템에 가해서, 성능/안정성이 요구사항을 만족하는지 검증하는 테스트로 정의해볼 수 있습니다. 즉, "실제 운영 수준의 부하에서 서비스가 정상 동작하는가?"를 확인합니다. 부하 테스트를 쉽게 해볼 수 있는 방법은 nGrinder, k6 등의 도구를 활용하는 것입니다. 이를 통하여 서비스가 정상 작동하는 부하량을 미리 파악하고, 문제 지점을 미리 파악해볼 수 있을 것입니다. 정상적으로 동작하던 프로그램이, 서비스 당일 동작하지 않는 경험을 해보고 싶지 않으시다면, 부하 테스트는 필수라고 생각합니다. 그런데 "이런 당혹스러운 경험을 직접 겪어보고 성장하는 것이, 사실은 더 좋지 않을까?"라고 생각하긴 합니다.

## 2. 아쉬웠던 점

이렇게 문제 원인을 파악했습니다. 다만 이러한 문제 원인은 대회 당일이 아니라, 이후 여러 차례의 검증 과정을 거친 뒤에야 정확히 확인할 수 있었습니다. 만약 대회 당일에 원인을 바로 파악했다면, 그 자리에서 신속하게 문제를 해결할 수 있었을 것입니다. 또한 개발 과정을 더 효율적으로 진행했다면, 테스트에 투입할 수 있는 리소스를 확보하여 서비스를 한층 더 안정적으로 운영할 수 있었을 것입니다. 지금부터는 이러한 아쉬웠던 지점들을, 과거로 돌아간다면 어떻게 해소할 수 있을지 소개하려합니다.

### 에러 핸들링 및 로깅

좋은 엔지니어링이란 모든 상황에 적용되는 만능키를 찾는 것도 포함될 수 있겠습니다. 그런데 그 만능키는 세부 기술이 아닌, 추상화된 개념일 가능성이 높습니다. 개별 기술이 모든 상황에 fit하다면, 이는 정말 좋은 기술이겠죠. 하지만 대부분의 개별 기술은 그 상황(기존 레거시, 리소스 등)에 맞게 사용됩니다. 여기서 좋은 말이 하나 나온 것 같습니다. 그 상황에 맞게 좋은 개별 기술을 선택한다는 것이죠. 좋은 엔지니어링에는 그 상황에서 최선의 선택을 찾는 것 또한 포함된다고 생각합니다.

그렇다면 try-catch는 만능키일까요? try-catch는 강력한 에러 핸들링 구문임에는 분명합니다. 하지만 모든 상황에서 try-catch만을 반복적으로 활용하는 것은 과연 좋은 엔지니어링일까요? 단연코 아니라고 말할 수 있겠습니다. 왜냐하면 try-catch를 반복적으로 사용한다면, 가독성이 굉장히 떨어지고, 에러 발생 지점을 찾기 어려워지기도 합니다.

try-catch로 인하여 가독성이 떨어지는 경험은 다들 한번쯤 해보셨으리라 생각합니다. 코드의 tab depth가 늘어나면서 로직의 흐름을 한눈에 파악하기 어려워지는 경우가 많습니다. 특히 try-catch가 중첩되면 재앙과도 같죠.

더하여 에러 발생 지점을 찾기 어려워지는 경우도 발생합니다. 예를들어 service layer가 repository layer를 호출한다고 가정해봅시다. 이때 repository layer에서 단순 console error를 호출하고 예외를 service layer로 전달하지 않으면, 정확한 로깅이 불가능해질 수 있습니다. 결국 로그만 잔뜩 남고, 원인을 파악하기 위해 모든 레이어의 코드를 일일이 확인해야 하는 비효율적인 상황에 직면하게 됩니다.

이러한 문제를 피하기 위해서는 에러 처리의 책임을 명확히 하는 설계가 필요합니다. 각 레이어마다 무분별하게 try-catch를 남발하기보다는, 특정 레이어(ex. 최상위 라우터 또는 글로벌 에러 핸들러)에서만 에러를 처리하고, 나머지 레이어에서는 발생한 예외를 그대로 상위로 전달하는 방식이 좋다고 생각합니다. 예를 들어, repository layer와 service layer는 에러를 잡아 로깅하거나 변환할 수 있지만, 최종적으로는 이를 라우터로 보내고, 라우터는 글로벌 에러 핸들러로 전달하여 일관된 방식으로 응답을 생성하는 것이 좋은 에러 관리 방식이라고 생각합니다. 이렇게 하면 코드의 들여쓰기 깊이를 줄여 가독성을 높일 수 있고, 에러 발생 지점을 명확히 추적할 수 있으며, 에러 처리 로직이 한 곳에 모여 유지보수가 용이해집니다.

계수기 소프트웨어의 개발 과정에서 try-catch를 남발하는 개발 방식을 택했다가, 재앙과도 같다고 생각하여 코드를 수정하느라 시간을 낭비했던 것 같습니다. 사실 그 당시 더 좋은 엔지니어링은 에러 처리 로직에 신경쓸 바에, 테스트를 많이 하는게 좋았을 것 같긴합니다. 그리고 제일 좋은 엔지니어링은 제가 에러 처리 설계를 경험해보았고, 이를 그대로 설계에 적용하여, 일이 원큐에 끝나는 것이겠죠. 여러분은 저와 같은 실수를 하지 마시고, 깔끔한 에러 처리 설계를 처음부터 지향하시길 바라겠습니다.

### 명세

명세! 명세! 명세! 누구나 중요함을 알지만, 특히 소규모 프로젝트에서는 많이들 작성하지 않는 것 중 하나죠. 왜 대부분의 소규모 프로젝트에서 명세서를 작성하지 않는 것일까요? 사소하다고 생각하거나, 명세를 작성하는 시간에 개발을 더해서 속도를 내자는 생각이 강한 것 같습니다. 저도 여기에 일부 동의합니다. 소규모 프로젝트에서 모든 것을 완벽히 정하고 개발에 착수하는 것은 경험 상 불가능에 가깝고 비효율적이라고 생각합니다. 하지만 서비스의 골격을 구성하는 요소에 대한 명세는 필요한 것 같습니다. 예를들어 데이터의 Model이나, API 명세, 페이지 명세 등의 서비스의 골격을 이루는 명세가 있겠네요. 그런데 여기에서 '왜?'라는 질문을 던져야합니다. 정말 데이터의 Model, API 명세, 통신 명세 작성은 개발 이전에 꼭 필요할까요?

골격을 이루는 요소를 정해두지 않으면 추후 설계 아키텍처 자체가 꼬일 위험이 큽니다. 저의 경우에는 프론트 페이지 명세를 정해두지 않았습니다. 이에 페이지 구현 단계에서 기능 위치, UI 흐름, 데이터 연동 방식 등을 즉흥적으로 결정하게 되어 작업 효율이 급격히 떨어졌습니다. 더하여 백엔드에서도 에러 응답에 대한 명세를 적어두었다면, 에러 처리 로직을 미리 생각하며 개발할 수 있었으리라 생각합니다. 즉, 서비스의 골격을 이루는 요소를 미리 명세한다면, 추후 코드를 갈아엎을 일은 적어질 것 같습니다.

또한 명세는 단순히 구조를 정의하는 것에 그치지 않고, 일정 관리의 기반이 된다고 생각합니다. "오늘은 API 3개를 완성한다", "이번 주에는 관리자 페이지를 마무리한다"처럼 작업 단위를 구체적으로 쪼개어 계획할 수 있게 됩니다. 저는 이러한 명세를 적어두지 않았기에, 망망대해에서 무지성으로 돌진하는 개발을 했던 것 같습니다.

더 나아가, 에자일하게 프로젝트를 운영하려면 전체적인 구조를 먼저 확립하고, 그 안에서 개발 단위를 잘게 나누어 반복적으로 개선하는 것이 좋습니다. 이때 그 구조의 기준이 되는 것이 바로 명세입니다. 저의 경우에는 명세가 없이 개발하여, 단위를 정하는 발상 자체가 불가능해졌으며, 우선순위나 작업 범위 설정에서도 계속 혼란이 발생했습니다.

즉, 서비스의 골격이 되는 명세는 미리 정해두고 개발을 진행하는 것이 매우 중요하다고 생각합니다.

### Props Drilling

Props Drilling은 정말 재앙입니다. 재앙을 겪지 않으려면, 적어도 재앙이 무엇인지 알아야겠지요? Props Drilling에 대해 알아봅시다.

React에서의 Props Drilling이란, 부모 컴포넌트가 가진 데이터를 중간에 필요 없는 컴포넌트들을 거쳐 최종적으로 필요한 하위 컴포넌트까지 props로 전달하는 패턴을 말합니다. 이는 데이터 흐름이 깊어질수록 중간 컴포넌트들이 불필요한 props를 받게 하는 문제를 야기합니다. 예를 살펴봅시다.

```js
// App.js
import React from "react";

function App() {
  const userName = "Alice";
  return <Parent userName={userName} />;
}

function Parent({ userName }) {
  // Parent는 userName을 쓰지 않지만 Child로 전달
  return <Child userName={userName} />;
}

function Child({ userName }) {
  // Child도 userName을 쓰지 않지만 GrandChild로 전달
  return <GrandChild userName={userName} />;
}

function GrandChild({ userName }) {
  // 여기서만 userName을 실제 사용
  return <h1>Hello, {userName}!</h1>;
}

export default App;
```

위 코드로 간단히 말하자면, `GrandChild`에서 쓰는 `userName`이라는 prop을, `Parent`와 `Child` 컴포넌트를 거쳐서 받는 코드입니다. 아직 재앙 같지 않다고요? prop이 4, 5개 되는 순간, 여러분은 이마를 짚게 될 것입니다. 가독성이 너무나 떨어지고, 컴포넌트의 모듈화 또한 어려워집니다. 유지보수는 당연 쉽지 않아지죠. 즉, 제가 생각하기에 Props Drilling은, 웬만하면 피해야 할 아키텍쳐인 것 같습니다.(Props Drilling을 안쓰면 더 큰 재앙이 오는 경우를 제외하곤..)

이를 해결하기 위해서는 React의 Context API나 기타 상태 관리 라이브러리를 활용하면 좋습니다. 제가 이를 미리 알았다면, 개발 효율성이 배로 증가했으리라 생각합니다. 여러분은 저와 같은 실수를 저지르지 않으시길 바라겠습니다.

## 3. 잘했던 점

계수기 소프트웨어를 제작/배포하며 잘했던 점은 없었을까요? 하나 정도는 있었던 것 같습니다. 지금부터는 계수기 소프트웨어를 제작/배포하며 잘했던 점을 소개하려합니다.

### 참가자 만족도

모든 기술은 그 목적을 명확히 가질때, 빛이 나는 것 같습니다. 라인트레이서 계수기 소프트웨어 개발 목적은, 대회 참여자가 실시간으로 자신의 순위를 확인할 수 있도록 하는 플랫폼을 만드는 것이었습니다. 이를 위하여 기존 로컬에서 이루어지던 대회 시스템을 웹 서비스로 전환해야했고, 그 과정에서 상술한 문제들이 터진 것이지요. 그럼에도 불구하고 대회 당일 대회 참여자가 실시간으로 자신의 순위를 확인하는 기능은 정상 작동하였습니다.

이에 대회 참여자를 대상으로 만족도 조사를 진행하였고, 생각보다 반응은 좋았습니다. "자신의 차례를 실시간으로 확인할 수 있는 기능은 유용했나요?"라는 설문에 12명의 설문 참여자 모두, 매우 유용하다고 답하셨습니다. 이렇게 서비스를 운영하고 만족도를 조사하여 수치화하는 것은 중요한 것 같습니다.

## 4. 나오며

실패는 성공의 어머니라는 격언이 있습니다. 하지만 여기에서 실패를 정확히 정의할 필요가 있습니다. 이 글의 사례처럼 서비스의 핵심 기능이 실패하는 등의, 프로젝트의 전반적인 실패도 있을 것입니다. 혹은 프로젝트 전반적으로는 성공했지만, 일부분 실패를 경험할 수도 있겠습니다. 제 생각에는 실패가 성공의 어머니임에도 불구하고, 전자처럼 프로젝트 전체를 날려먹는 것은 바람직하지 않다고 생각합니다. 후자처럼 프로젝트를 전체적으로 성공시키고, 그 안에서의 실패를 보완하는 것이 리스크 관리 측면에서 좋다고 생각합니다. 즉, 실패를 해도 적당히 실패했어야 했는데, 이 프로젝트는 적당한 실패는 아니었던 것 같습니다. 하지만 이러한 실패를 통하여, 더욱 성장하고 발전해나가는 것이 중요하다고 생각합니다.

저는 이 실패를 통하여 많은 것을 배웠습니다. 그리고 이후 프로젝트에서 이러한 실패를 밑거름삼아 좋은 결과를 이루어낼 수 있었습니다. 다음 포스팅은 이 프로젝트의 실패로부터 배운 교훈을 통하여, 좋은 성과를 이끌어낸 창의적 종합설계 경진대회에서의 경험을 소개하려합니다.

(실패는 성공의 어머니입니다. 그런데 성공이란 존재하는 것일까요? '성공'이라는 이름으로 불리는 것에서도, 작은 실패를 찾아내고 발전하는 것이 바람직하진 않을까요? "나는 성공했어."라고 말하는 순간 우리는 성공에서 멀어질지도 모르겠습니다.)
